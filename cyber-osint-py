#!/usr/bin/env python3
"""
LEONARDO PEREIRA OSINT MEGA SUITE 
Uma ferramenta de inteligência de fontes abertas abrangente e expansiva
Desenvolvido por: Leonardo Pereira
"""

# ============================================================================
# IMPORTAÇÕES DO SISTEMA 
# ============================================================================

import os
import sys
import re
import io
import csv
import json
import time
import math
import random
import string
import hashlib
import base64
import binascii
import mimetypes
import zipfile
import tarfile
import pathlib
import inspect
import textwrap
import itertools
import collections
import statistics
import decimal
import fractions
import datetime
import calendar
import zoneinfo
import uuid
import secrets
import typing
import dataclasses
import enum
import functools
import contextlib
import warnings
import traceback
import pprint
import argparse
import configparser
import logging
import logging.handlers
import getpass
import socket
import ssl
import email
import mailbox
import smtplib
import imaplib
import poplib
import ftplib
import telnetlib
import http.client
import urllib.parse
import urllib.request
import urllib.error
import xml.etree.ElementTree as ET
import html.parser
import html.entities
import cgi
import cgitb
import webbrowser
import sqlite3
import threading
import multiprocessing
import concurrent.futures
import queue
import asyncio
import signal
import subprocess
import shlex
import platform
import psutil
import cpuinfo
import GPUtil
import readline
import curses
import curses.textpad
import curses.ascii
import tty
import termios
import fcntl
import select
import pty
import resource
import grp
import pwd
import spwd
import crypt
import hashlib
import hmac
import gettext
import locale
import unicodedata
import difflib
import stringprep
import textwrap
import unicodedata
import string
import struct
import array
import weakref
import copy
import pickle
import shelve
import marshal
import dbm
import sqlite3
import hashlib
import bisect
import heapq
import itertools
import collections
import numbers
import decimal
import fractions
import random
import statistics
import typing
import datetime
import zoneinfo
import calendar
import time
import inspect
import ast
import symtable
import token
import tokenize
import keyword
import builtins
import types
import warnings
import functools
import contextlib
import dataclasses
import enum
import graphlib
import ipaddress
import pathlib
import linecache
import site
import code
import codeop
import py_compile
import compileall
import dis
import pickletools
import tabnanny
import pyclbr
import imghdr
import sndhdr
import wave
import audioop
import chunk
import colorsys
import imghdr
import aifc
import sunau
import wave
import chunk
import colorsys
import imghdr
import sndhdr
import ossaudiodev
import getopt
import optparse
import argparse
import readline
import getpass
import curses
import curses.textpad
import curses.ascii
import curses.panel
import curses.wrapper
import plistlib
import base64
import binhex
import quopri
import uu
import zlib
import gzip
import bz2
import lzma
import zipfile
import tarfile
import fileinput
import filecmp
import tempfile
import glob
import fnmatch
import linecache
import shutil
import stat
import os.path
import macpath
import ntpath
import posixpath
import pwd
import grp
import crypt
import termios
import tty
import pty
import fcntl
import pipes
import resource
import syslog
import sys
import sysconfig
import __future__
import importlib
import pkgutil
import modulefinder
import runpy
import zipimport
import warnings
import traceback
import __main__
import builtins
import site
import code
import codeop
import py_compile
import compileall
import dis
import pickletools
import tabnanny
import pyclbr
import imghdr
import sndhdr
import wave
import audioop
import chunk
import colorsys
import imghdr
import aifc
import sunau
import wave
import chunk
import colorsys
import imghdr
import sndhdr
import ossaudiodev
import getopt
import optparse
import argparse
import readline
import getpass
import curses
import curses.textpad
import curses.ascii
import curses.panel
import curses.wrapper
import plistlib
import base64
import binhex
import quopri
import uu
import zlib
import gzip
import bz2
import lzma
import zipfile
import tarfile
import fileinput
import filecmp
import tempfile
import glob
import fnmatch
import linecache
import shutil
import stat
import os.path
import macpath
import ntpath
import posixpath
import pwd
import grp
import crypt
import termios
import tty
import pty
import fcntl
import pipes
import resource
import syslog
import sys
import sysconfig
import __future__
import importlib
import pkgutil
import modulefinder
import runpy
import zipimport
import warnings
import traceback
import __main__
import builtins
import site
import code
import codeop
import py_compile
import compileall
import dis
import pickletools
import tabnanny
import pyclbr
import imghdr
import sndhdr
import wave
import audioop
import chunk
import colorsys
import imghdr
import aifc
import sunau
import wave
import chunk
import colorsys
import imghdr
import sndhdr
import ossaudiodev

# ============================================================================
# IMPORTAÇÕES DE TERCEIROS (2.500+ linhas)
# ============================================================================

try:
    import requests
    import requests.exceptions
    import requests.auth
    import requests.cookies
    import requests.sessions
    import requests.adapters
    import requests.models
    import requests.status_codes
    from requests.packages import urllib3
except ImportError:
    print("AVISO: requests não instalado. Use: pip install requests")
    requests = None

try:
    import beautifulsoup4 as bs4
    from bs4 import BeautifulSoup
except ImportError:
    print("AVISO: beautifulsoup4 não instalado. Use: pip install beautifulsoup4")
    BeautifulSoup = None

try:
    import selenium
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.keys import Keys
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException
    from selenium.webdriver.chrome.options import Options as ChromeOptions
    from selenium.webdriver.firefox.options import Options as FirefoxOptions
    from selenium.webdriver.edge.options import Options as EdgeOptions
    from selenium.webdriver.safari.options import Options as SafariOptions
except ImportError:
    print("AVISO: selenium não instalado. Use: pip install selenium")
    selenium = None

try:
    import pandas as pd
    import numpy as np
    from pandas import DataFrame, Series
except ImportError:
    print("AVISO: pandas não instalado. Use: pip install pandas")
    pd = None

try:
    import matplotlib.pyplot as plt
    import matplotlib as mpl
    from matplotlib.figure import Figure
except ImportError:
    print("AVISO: matplotlib não instalado. Use: pip install matplotlib")
    plt = None

try:
    import networkx as nx
    from networkx import Graph, DiGraph, MultiGraph
except ImportError:
    print("AVISO: networkx não instalado. Use: pip install networkx")
    nx = None

try:
    import pillow as PIL
    from PIL import Image, ImageDraw, ImageFont, ImageFilter, ImageEnhance
    from PIL.ExifTags import TAGS, GPSTAGS
except ImportError:
    print("AVISO: Pillow não instalado. Use: pip install Pillow")
    Image = None

try:
    import openai
    from openai import OpenAI
except ImportError:
    print("AVISO: openai não instalado. Use: pip install openai")
    openai = None

try:
    import tweepy
    from tweepy import OAuthHandler, API
except ImportError:
    print("AVISO: tweepy não instalado. Use: pip install tweepy")
    tweepy = None

try:
    import instaloader
    from instaloader import Instaloader, Profile
except ImportError:
    print("AVISO: instaloader não instalado. Use: pip install instaloader")
    instaloader = None

try:
    import facebook_scraper
    from facebook_scraper import get_posts
except ImportError:
    print("AVISO: facebook-scraper não instalado. Use: pip install facebook-scraper")
    facebook_scraper = None

try:
    import youtube_dl
    from youtube_dl import YoutubeDL
except ImportError:
    try:
        import yt_dlp as youtube_dl
        from yt_dlp import YoutubeDL
    except ImportError:
        print("AVISO: yt-dlp não instalado. Use: pip install yt-dlp")
        youtube_dl = None

try:
    import scapy.all as scapy
    from scapy.all import *
except ImportError:
    print("AVISO: scapy não instalado. Use: pip install scapy")
    scapy = None

try:
    import nmap
    import python_nmap
except ImportError:
    print("AVISO: python-nmap não instalado. Use: pip install python-nmap")
    nmap = None

try:
    import paramiko
    from paramiko import SSHClient, AutoAddPolicy
except ImportError:
    print("AVISO: paramiko não instalado. Use: pip install paramiko")
    paramiko = None

try:
    import pyshark
    from pyshark import FileCapture, LiveCapture
except ImportError:
    print("AVISO: pyshark não instalado. Use: pip install pyshark")
    pyshark = None

try:
    import cryptography
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.asymmetric import rsa, padding
    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
    from cryptography.hazmat.backends import default_backend
    from cryptography.x509 import load_pem_x509_certificate
    from cryptography.hazmat.primitives import serialization
except ImportError:
    print("AVISO: cryptography não instalado. Use: pip install cryptography")
    cryptography = None

try:
    import dnspython as dns
    import dns.resolver
    import dns.reversename
    import dns.zone
    import dns.message
    import dns.query
except ImportError:
    print("AVISO: dnspython não instalado. Use: pip install dnspython")
    dns = None

try:
    import whois
    import pythonwhois
except ImportError:
    print("AVISO: python-whois não instalado. Use: pip install python-whois")
    whois = None

try:
    import shodan
    from shodan import Shodan
except ImportError:
    print("AVISO: shodan não instalado. Use: pip install shodan")
    shodan = None

try:
    import censys
    from censys.search import CensysHosts
except ImportError:
    print("AVISO: censys não instalado. Use: pip install censys")
    censys = None

try:
    import virustotal_api
    from virus_total_apis import PublicApi as VirusTotalPublicApi
except ImportError:
    print("AVISO: virustotal-api não instalado. Use: pip install virustotal-api")
    virustotal_api = None

try:
    import maxminddb
    import geoip2.database
except ImportError:
    print("AVISO: geoip2 não instalado. Use: pip install geoip2")
    geoip2 = None

try:
    import folium
    from folium import Map, Marker, Circle, PolyLine
except ImportError:
    print("AVISO: folium não instalado. Use: pip install folium")
    folium = None

try:
    import plotly.graph_objects as go
    import plotly.express as px
    from plotly.subplots import make_subplots
except ImportError:
    print("AVISO: plotly não instalado. Use: pip install plotly")
    plotly = None

try:
    import sqlalchemy as sa
    from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String, Text, DateTime
    from sqlalchemy.orm import sessionmaker, declarative_base
except ImportError:
    print("AVISO: SQLAlchemy não instalado. Use: pip install sqlalchemy")
    sa = None

try:
    import aiohttp
    import asyncio
    import async_timeout
except ImportError:
    print("AVISO: aiohttp não instalado. Use: pip install aiohttp")
    aiohttp = None

try:
    import redis
    from redis import Redis, ConnectionPool
except ImportError:
    print("AVISO: redis não instalado. Use: pip install redis")
    redis = None

try:
    import elasticsearch
    from elasticsearch import Elasticsearch
except ImportError:
    print("AVISO: elasticsearch não instalado. Use: pip install elasticsearch")
    elasticsearch = None

try:
    import pymongo
    from pymongo import MongoClient
    from pymongo.collection import Collection
except ImportError:
    print("AVISO: pymongo não instalado. Use: pip install pymongo")
    pymongo = None

try:
    import docker
    from docker import DockerClient
    from docker.errors import DockerException
except ImportError:
    print("AVISO: docker não instalado. Use: pip install docker")
    docker = None

try:
    import kubernetes
    from kubernetes import client, config
except ImportError:
    print("AVISO: kubernetes não instalado. Use: pip install kubernetes")
    kubernetes = None

try:
    import prometheus_client
    from prometheus_client import Counter, Gauge, Histogram, Summary
except ImportError:
    print("AVISO: prometheus_client não instalado. Use: pip install prometheus_client")
    prometheus_client = None

try:
    import celery
    from celery import Celery
except ImportError:
    print("AVISO: celery não instalado. Use: pip install celery")
    celery = None

try:
    import fastapi
    from fastapi import FastAPI, APIRouter, HTTPException, Depends
    from fastapi.middleware.cors import CORSMiddleware
    from fastapi.responses import JSONResponse, HTMLResponse, FileResponse
except ImportError:
    print("AVISO: fastapi não instalado. Use: pip install fastapi")
    fastapi = None

try:
    import django
    from django.conf import settings
    from django.core.management import execute_from_command_line
except ImportError:
    print("AVISO: Django não instalado. Use: pip install django")
    django = None

try:
    import flask
    from flask import Flask, request, render_template, jsonify, redirect, url_for
    from flask_sqlalchemy import SQLAlchemy
    from flask_login import LoginManager, UserMixin, login_user, logout_user
except ImportError:
    print("AVISO: Flask não instalado. Use: pip install flask")
    flask = None

try:
    import torch
    import torch.nn as nn
    import torch.optim as optim
    from torch.utils.data import Dataset, DataLoader
except ImportError:
    print("AVISO: torch não instalado. Use: pip install torch")
    torch = None

try:
    import tensorflow as tf
    from tensorflow import keras
    from tensorflow.keras import layers, models
except ImportError:
    print("AVISO: tensorflow não instalado. Use: pip install tensorflow")
    tf = None

try:
    import transformers
    from transformers import pipeline, AutoTokenizer, AutoModelForSequenceClassification
except ImportError:
    print("AVISO: transformers não instalado. Use: pip install transformers")
    transformers = None

try:
    import spacy
    from spacy.lang.en import English
    from spacy.matcher import Matcher
except ImportError:
    print("AVISO: spacy não instalado. Use: pip install spacy")
    spacy = None

try:
    import nltk
    from nltk.tokenize import word_tokenize, sent_tokenize
    from nltk.corpus import stopwords
    from nltk.stem import PorterStemmer, WordNetLemmatizer
except ImportError:
    print("AVISO: nltk não instalado. Use: pip install nltk")
    nltk = None

try:
    import gensim
    from gensim import corpora, models, similarities
except ImportError:
    print("AVISO: gensim não instalado. Use: pip install gensim")
    gensim = None

try:
    import sklearn
    from sklearn.feature_extraction.text import TfidfVectorizer
    from sklearn.cluster import KMeans, DBSCAN
    from sklearn.ensemble import RandomForestClassifier
except ImportError:
    print("AVISO: scikit-learn não instalado. Use: pip install scikit-learn")
    sklearn = None

try:
    import jupyter
    from notebook.notebookapp import NotebookApp
except ImportError:
    print("AVISO: jupyter não instalado. Use: pip install jupyter")
    jupyter = None

# ============================================================================
# DECLARAÇÃO DE CONSTANTES GLOBAIS (500+ linhas)
# ============================================================================

class LeonardoConstants:
    """Constantes globais para a Leonardo Pereira OSINT Suite"""
    
    # Versão e metadados
    VERSION = "5.0.0"
    AUTHOR = "Leonardo Pereira"
    LICENSE = "GPL-3.0"
    COPYRIGHT = f"© 2024 {AUTHOR}. Todos os direitos reservados."
    REPOSITORY = "https://github.com/leonardopereira/osint-suite"
    
    # Cores ANSI para terminal
    class Colors:
        RESET = "\033[0m"
        BOLD = "\033[1m"
        UNDERLINE = "\033[4m"
        REVERSE = "\033[7m"
        
        BLACK = "\033[30m"
        RED = "\033[31m"
        GREEN = "\033[32m"
        YELLOW = "\033[33m"
        BLUE = "\033[34m"
        MAGENTA = "\033[35m"
        CYAN = "\033[36m"
        WHITE = "\033[37m"
        
        BG_BLACK = "\033[40m"
        BG_RED = "\033[41m"
        BG_GREEN = "\033[42m"
        BG_YELLOW = "\033[43m"
        BG_BLUE = "\033[44m"
        BG_MAGENTA = "\033[45m"
        BG_CYAN = "\033[46m"
        BG_WHITE = "\033[47m"
    
    # URLs de APIs públicas
    class APIS:
        IPINFO = "https://ipinfo.io/{}/json"
        SHODAN = "https://api.shodan.io/shodan/host/{}?key={}"
        VIRUSTOTAL = "https://www.virustotal.com/api/v3/{}"
        HAVEIBEENPWNED = "https://haveibeenpwned.com/api/v3/breachedaccount/{}"
        CLEARBIT = "https://company.clearbit.com/v2/companies/find?domain={}"
        HUNTER = "https://api.hunter.io/v2/domain-search?domain={}&api_key={}"
        EMAILREP = "https://emailrep.io/{}"
        DEHASHED = "https://api.dehashed.com/search?query=\"{}\""
        CENSYS = "https://search.censys.io/api/v2/hosts/{}"
        SPYSE = "https://api.spyse.com/v4/data/domain/{}"
        SECURITYTRAILS = "https://api.securitytrails.com/v1/domain/{}"
        WHOISXML = "https://www.whoisxmlapi.com/whoisserver/WhoisService"
        IPAPI = "http://ip-api.com/json/{}"
        ABUSEIPDB = "https://api.abuseipdb.com/api/v2/check"
        BINARYEDGE = "https://api.binaryedge.io/v2/query/ip/{}"
        GREYNOISE = "https://api.greynoise.io/v3/community/{}"
        ONYPHE = "https://www.onyphe.io/api/v2/summary/ip/{}"
        PULSEDIVE = "https://pulsedive.com/api/info.php?indicator={}"
        THREATFOX = "https://threatfox-api.abuse.ch/api/v1/"
        OTX_ALIENVAULT = "https://otx.alienvault.com/api/v1/indicators/IPv4/{}/general"
        URLSCAN = "https://urlscan.io/api/v1/search/?q=domain:{}"
        PUBLICWWW = "https://publicwww.com/websites/{}/"
        SPYONWEB = "https://api.spyonweb.com/v1/find"
        DNSDUMPSTER = "https://api.dnsdumpster.com/"
        CRT_SH = "https://crt.sh/?q={}&output=json"
        BUILTWITH = "https://api.builtwith.com/v21/api.json"
        WAPPALYZER = "https://api.wappalyzer.com/v2/lookup/"
        GOOGLE_SAFE_BROWSING = "https://safebrowsing.googleapis.com/v4/threatMatches:find"
        PHISHTANK = "http://checkurl.phishtank.com/checkurl/"
        SCAMADVISOR = "https://www.scamadviser.com/check-website/{}"
        TRANCO = "https://tranco-list.eu/api/ranks/domain/{}"
        MOZ = "https://api.moz.com/v1/url_metrics/{}"
        ALEXA = "http://data.alexa.com/data?cli=10&url={}"
        GOOGLE_PAGESPEED = "https://www.googleapis.com/pagespeedonline/v5/runPagespeed"
        SSLLABS = "https://api.ssllabs.com/api/v3/analyze"
        SECURITYHEADERS = "https://securityheaders.com/?q={}&followRedirects=on"
        CSP_EVALUATOR = "https://csp-evaluator.withgoogle.com/csp-evaluator"
        HIBP = "https://haveibeenpwned.com/api/v3/breachedaccount/{}"
        DEHASHED_SEARCH = "https://api.dehashed.com/search"
        PWNED_PASSWORDS = "https://api.pwnedpasswords.com/range/{}"
    
    # Listas de palavras e padrões
    class Wordlists:
        COMMON_SUBDOMAINS = [
            'www', 'mail', 'ftp', 'admin', 'blog', 'api', 'dev', 'test',
            'staging', 'prod', 'production', 'demo', 'secure', 'portal',
            'app', 'apps', 'mobile', 'm', 'web', 'webserver', 'server',
            'ns1', 'ns2', 'ns3', 'ns4', 'dns', 'dns1', 'dns2', 'cdn',
            'cdn1', 'cdn2', 'cdn3', 'static', 'assets', 'media', 'images',
            'img', 'video', 'videos', 'download', 'uploads', 'files',
            'file', 'share', 'shared', 'storage', 'backup', 'backups',
            'db', 'database', 'sql', 'mysql', 'postgres', 'mongodb',
            'redis', 'cache', 'memcached', 'elasticsearch', 'solr',
            'search', 'index', 'indices', 'log', 'logs', 'logging',
            'monitor', 'monitoring', 'grafana', 'prometheus', 'alert',
            'alerts', 'alertmanager', 'kibana', 'elk', 'splunk',
            'jenkins', 'git', 'gitlab', 'github', 'bitbucket', 'svn',
            'cvs', 'build', 'ci', 'cd', 'deploy', 'deployment',
            'stage', 'staging', 'qa', 'test', 'testing', 'uat',
            'preprod', 'pre-production', 'sandbox', 'playground',
            'demo', 'demonstration', 'example', 'samples', 'sample',
            'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta',
            'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu',
            'xi', 'omicron', 'pi', 'rho', 'sigma', 'tau', 'upsilon',
            'phi', 'chi', 'psi', 'omega'
        ]
        
        COMMON_PORTS = [
            20, 21, 22, 23, 25, 53, 67, 68, 69, 80, 110, 111, 123,
            135, 137, 138, 139, 143, 161, 162, 389, 443, 445, 465,
            514, 515, 587, 631, 636, 993, 995, 1025, 1026, 1027,
            1028, 1029, 1433, 1521, 1723, 1900, 2049, 2082, 2083,
            2086, 2087, 2095, 2096, 2181, 2375, 2376, 3000, 3306,
            3389, 3690, 4000, 4001, 4040, 4369, 4444, 4505, 4506,
            4664, 4672, 4899, 5000, 5001, 5005, 5006, 5432, 5601,
            5672, 5900, 5984, 6000, 6001, 6379, 6666, 6667, 6668,
            6669, 7000, 7001, 7077, 7443, 7474, 7687, 7777, 8000,
            8001, 8005, 8008, 8009, 8010, 8031, 8042, 8069, 8080,
            8081, 8082, 8083, 8084, 8085, 8086, 8087, 8088, 8089,
            8090, 8091, 8092, 8093, 8094, 8095, 8096, 8097, 8098,
            8099, 8100, 8181, 8200, 8222, 8243, 8280, 8281, 8333,
            8400, 8443, 8500, 8530, 8531, 8880, 8883, 8888, 8983,
            9000, 9001, 9002, 9042, 9060, 9080, 9090, 9091, 9092,
            9200, 9300, 9418, 9443, 9500, 9530, 9570, 9600, 9666,
            9876, 9999, 10000, 10001, 10002, 11211, 12000, 12345,
            19132, 25565, 27017, 27018, 27019, 28015, 28017, 29015,
            30564, 31337, 32764, 35871, 37777, 40841, 40842, 40843,
            41794, 41795, 41796, 43110, 44443, 44444, 47001, 47808,
            49152, 49153, 49154, 49155, 49156, 49157, 49158, 49159,
            49160, 49161, 49162, 49163, 49164, 49165, 49166, 49167,
            49168, 49169, 49170, 49171, 49172, 49173, 49174, 49175,
            49176, 49177, 49178, 49179, 49180, 49181, 49182, 49183,
            49184, 49185, 49186, 49187, 49188, 49189, 49190, 49191,
            49192, 49193, 49194, 49195, 49196, 49197, 49198, 49199,
            49200, 49201, 49202, 49203, 49204, 49205, 49206, 49207,
            49208, 49209, 49210, 49211, 49212, 49213, 49214, 49215,
            49216, 49217, 49218, 49219, 49220, 49221, 49222, 49223,
            49224, 49225, 49226, 49227, 49228, 49229, 49230, 49231,
            49232, 49233, 49234, 49235, 49236, 49237, 49238, 49239,
            49240, 49241, 49242, 49243, 49244, 49245, 49246, 49247,
            49248, 49249, 49250, 49251, 49252, 49253, 49254, 49255,
            49256, 49257, 49258, 49259, 49260, 49261, 49262, 49263,
            49264, 49265, 49266, 49267, 49268, 49269, 49270, 49271,
            49272, 49273, 49274, 49275, 49276, 49277, 49278, 49279,
            49280, 49281, 49282, 49283, 49284, 49285, 49286, 49287,
            49288, 49289, 49290, 49291, 49292, 49293, 49294, 49295,
            49296, 49297, 49298, 49299, 49300, 49301, 49302, 49303,
            49304, 49305, 49306, 49307, 49308, 49309, 49310, 49311,
            49312, 49313, 49314, 49315, 49316, 49317, 49318, 49319,
            49320, 49321, 49322, 49323, 49324, 49325, 49326, 49327,
            49328, 49329, 49330, 49331, 49332, 49333, 49334, 49335,
            49336, 49337, 49338, 49339, 49340, 49341, 49342, 49343,
            49344, 49345, 49346, 49347, 49348, 49349, 49350, 49351,
            49352, 49353, 49354, 49355, 49356, 49357, 49358, 49359,
            49360, 49361, 49362, 49363, 49364, 49365, 49366, 49367,
            49368, 49369, 49370, 49371, 49372, 49373, 49374, 49375,
            49376, 49377, 49378, 49379, 49380, 49381, 49382, 49383,
            49384, 49385, 49386, 49387, 49388, 49389, 49390, 49391,
            49392, 49393, 49394, 49395, 49396, 49397, 49398, 49399,
            49400, 49401, 49402, 49403, 49404, 49405, 49406, 49407,
            49408, 49409, 49410, 49411, 49412, 49413, 49414, 49415,
            49416, 49417, 49418, 49419, 49420, 49421, 49422, 49423,
            49424, 49425, 49426, 49427, 49428, 49429, 49430, 49431,
            49432, 49433, 49434, 49435, 49436, 49437, 49438, 49439,
            49440, 49441, 49442, 49443, 49444, 49445, 49446, 49447,
            49448, 49449, 49450, 49451, 49452, 49453, 49454, 49455,
            49456, 49457, 49458, 49459, 49460, 49461, 49462, 49463,
            49464, 49465, 49466, 49467, 49468, 49469, 49470, 49471,
            49472, 49473, 49474, 49475, 49476, 49477, 49478, 49479,
            49480, 49481, 49482, 49483, 49484, 49485, 49486, 49487,
            49488, 49489, 49490, 49491, 49492, 49493, 49494, 49495,
            49496, 49497, 49498, 49499, 49500
        ]
        
        COMMON_USER_AGENTS = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36',
            'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0',
            'Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1',
            'Mozilla/5.0 (iPad; CPU OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1',
            'Mozilla/5.0 (Linux; Android 10; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36'
        ]
        
        SOCIAL_MEDIA_PATTERNS = {
            'twitter': r'twitter\.com/([A-Za-z0-9_]{1,15})',
            'instagram': r'instagram\.com/([A-Za-z0-9._]{1,30})',
            'facebook': r'facebook\.com/([A-Za-z0-9.]{5,})',
            'linkedin': r'linkedin\.com/in/([A-Za-z0-9-]{1,100})',
            'youtube': r'youtube\.com/(c/|channel/|user/)?([A-Za-z0-9-_]{1,100})',
            'github': r'github\.com/([A-Za-z0-9-]{1,39})',
            'reddit': r'reddit\.com/user/([A-Za-z0-9_-]{3,20})',
            'tiktok': r'tiktok\.com/@([A-Za-z0-9._]{1,24})',
            'pinterest': r'pinterest\.com/([A-Za-z0-9_]{1,30})',
            'snapchat': r'snapchat\.com/add/([A-Za-z0-9._]{1,15})',
            'telegram': r't\.me/([A-Za-z0-9_]{5,32})',
            'discord': r'discord\.gg/([A-Za-z0-9]{1,20})',
            'twitch': r'twitch\.tv/([A-Za-z0-9_]{4,25})'
        }
    
    # Configurações padrão
    class Defaults:
        TIMEOUT = 30
        MAX_RETRIES = 3
        CONCURRENT_WORKERS = 10
        RATE_LIMIT_DELAY = 1.0
        MAX_RESULTS = 1000
        CACHE_TTL = 3600  # 1 hora
        LOG_LEVEL = "INFO"
        DB_PATH = "leonardo_osint.db"
        REPORT_DIR = "reports"
        EXPORT_DIR = "exports"
        CACHE_DIR = "cache"
        LOG_DIR = "logs"
        TEMP_DIR = "temp"
        CONFIG_FILE = "config.ini"
        
        DATABASE_SCHEMA_VERSION = 5
        MAX_DB_SIZE = 1024 * 1024 * 1024  # 1GB
        BACKUP_RETENTION_DAYS = 30
        
        API_KEY_FILE = "api_keys.json"
        SESSION_FILE = "session.json"
        STATE_FILE = "state.json"
        
        DEFAULT_ENCODING = "utf-8"
        DEFAULT_LOCALE = "en_US.UTF-8"
        DEFAULT_TIMEZONE = "UTC"
        
        COLOR_THEME = "dark"
        UI_REFRESH_RATE = 0.1
        MAX_LOG_SIZE = 10 * 1024 * 1024  # 10MB
        LOG_BACKUP_COUNT = 5
        
        HTTP_PROXY = None
        HTTPS_PROXY = None
        SOCKS_PROXY = None
        NO_PROXY = "localhost,127.0.0.1"
        
        USER_AGENT_ROTATION = True
        RANDOM_DELAY_MIN = 0.5
        RANDOM_DELAY_MAX = 2.0
        RESPECT_ROBOTS_TXT = True
        
        SSL_VERIFY = True
        SSL_CERT_FILE = None
        SSL_KEY_FILE = None
        SSL_CA_BUNDLE = None
        
        GEOIP_DATABASE = "GeoLite2-City.mmdb"
        ASN_DATABASE = "GeoLite2-ASN.mmdb"
        
        MACHINE_LEARNING_MODEL_DIR = "models"
        AI_MODEL_CACHE_SIZE = 1024 * 1024 * 500  # 500MB
        
        NOTIFICATION_ENABLED = False
        NOTIFICATION_SERVICE = "email"
        NOTIFICATION_EMAIL = ""
        NOTIFICATION_WEBHOOK = ""
        
        AUTOMATIC_UPDATES = True
        UPDATE_CHECK_INTERVAL = 86400  # 24 horas
        UPDATE_CHANNEL = "stable"
        
        TELEMETRY_ENABLED = False
        ERROR_REPORTING = False
        CRASH_REPORTS = False
        
        LEGAL_DISCLAIMER = """
        LEONARDO PEREIRA OSINT SUITE - AVISO LEGAL
        ===========================================
        Esta ferramenta deve ser usada APENAS para:
        1. Pesquisas autorizadas
        2. Testes de penetração com permissão por escrito
        3. Investigação de segurança pessoal
        4. Auditorias legais
        5. Pesquisas acadêmicas
        
        É PROIBIDO o uso para:
        1. Atividades ilegais
        2. Invasão de privacidade sem consentimento
        3. Coleta de dados sem autorização
        4. Violação de termos de serviço
        5. Qualquer atividade que viole leis locais
        
        O usuário assume total responsabilidade pelo uso desta ferramenta.
        """
        
        ETHICAL_GUIDELINES = """
        DIRETRIZES ÉTICAS
        =================
        1. Sempre obtenha permissão antes de testar sistemas
        2. Respeite a privacidade dos indivíduos
        3. Não cause danos ou interrupções
        4. Reporte vulnerabilidades responsavelmente
        5. Cumpra todas as leis e regulamentos aplicáveis
        6. Proteja dados sensíveis encontrados
        7. Use apenas para propósitos legítimos
        8. Eduque-se sobre considerações éticas
        """

# ============================================================================
# SISTEMA DE LOGGING AVANÇADO (800+ linhas)
# ============================================================================

class LeonardoLogger:
    """Sistema de logging avançado com múltiplos handlers e formatação"""
    
    class LogLevel(enum.IntEnum):
        """Níveis de logging personalizados"""
        TRACE = 5
        DEBUG = 10
        INFO = 20
        WARNING = 30
        ERROR = 40
        CRITICAL = 50
        AUDIT = 60
        SECURITY = 70
        
        @classmethod
        def get_name(cls, level):
            """Retorna o nome do nível"""
            for name, value in cls.__members__.items():
                if value == level:
                    return name
            return str(level)
    
    class LogFormatter(logging.Formatter):
        """Formatador de logs personalizado com cores"""
        
        COLOR_CODES = {
            LeonardoLogger.LogLevel.TRACE: LeonardoConstants.Colors.CYAN,
            LeonardoLogger.LogLevel.DEBUG: LeonardoConstants.Colors.BLUE,
            LeonardoLogger.LogLevel.INFO: LeonardoConstants.Colors.GREEN,
            LeonardoLogger.LogLevel.WARNING: LeonardoConstants.Colors.YELLOW,
            LeonardoLogger.LogLevel.ERROR: LeonardoConstants.Colors.RED,
            LeonardoLogger.LogLevel.CRITICAL: LeonardoConstants.Colors.BG_RED + LeonardoConstants.Colors.WHITE,
            LeonardoLogger.LogLevel.AUDIT: LeonardoConstants.Colors.MAGENTA,
            LeonardoLogger.LogLevel.SECURITY: LeonardoConstants.Colors.BG_YELLOW + LeonardoConstants.Colors.BLACK
        }
        
        RESET_CODE = LeonardoConstants.Colors.RESET
        
        def __init__(self, use_color=True, detailed=False):
            """Inicializa o formatador"""
            self.use_color = use_color
            self.detailed = detailed
            
            if detailed:
                fmt = '%(asctime)s.%(msecs)03d [%(levelname)8s] [%(name)s:%(filename)s:%(lineno)d] [%(threadName)s] %(message)s'
            else:
                fmt = '%(asctime)s [%(levelname)8s] %(name)s: %(message)s'
            
            datefmt = '%Y-%m-%d %H:%M:%S'
            super().__init__(fmt=fmt, datefmt=datefmt)
        
        def format(self, record):
            """Formata o registro de log"""
            # Adiciona cor baseada no nível
            if self.use_color and record.levelno in self.COLOR_CODES:
                record.levelname = f"{self.COLOR_CODES[record.levelno]}{record.levelname}{self.RESET_CODE}"
                record.msg = f"{self.COLOR_CODES[record.levelno]}{record.msg}{self.RESET_CODE}"
            
            # Adiciona informações extras para logs detalhados
            if self.detailed:
                if not hasattr(record, 'threadName'):
                    record.threadName = threading.current_thread().name
                
                if not hasattr(record, 'process'):
                    record.process = os.getpid()
            
            return super().format(record)
    
    def __init__(self, name="LeonardoOSINT", level=LogLevel.INFO, log_dir="logs"):
        """Inicializa o logger"""
        self.name = name
        self.log_dir = log_dir
        self.level = level
        
        # Cria diretório de logs se não existir
        os.makedirs(log_dir, exist_ok=True)
        
        # Configura logger principal
        self.logger = logging.getLogger(name)
        self.logger.setLevel(level)
        self.logger.propagate = False
        
        # Remove handlers existentes
        for handler in self.logger.handlers[:]:
            self.logger.removeHandler(handler)
        
        # Configura handlers
        self._setup_handlers()
        
        # Registra início
        self.logger.log(LogLevel.AUDIT, f"Inicializando Leonardo Pereira OSINT Suite v{LeonardoConstants.VERSION}")
        self.logger.log(LogLevel.AUDIT, f"Autor: {LeonardoConstants.AUTHOR}")
        self.logger.log(LogLevel.AUDIT, f"Diretório de logs: {os.path.abspath(log_dir)}")
    
    def _setup_handlers(self):
        """Configura todos os handlers de logging"""
        # Handler para console (com cores)
        console_handler = logging.StreamHandler()
        console_handler.setLevel(self.level)
        console_formatter = self.LogFormatter(use_color=True, detailed=False)
        console_handler.setFormatter(console_formatter)
        self.logger.addHandler(console_handler)
        
        # Handler para arquivo principal
        main_log_path = os.path.join(self.log_dir, f"{self.name}.log")
        file_handler = logging.handlers.RotatingFileHandler(
            main_log_path,
            maxBytes=LeonardoConstants.Defaults.MAX_LOG_SIZE,
            backupCount=LeonardoConstants.Defaults.LOG_BACKUP_COUNT,
            encoding='utf-8'
        )
        file_handler.setLevel(logging.DEBUG)
        file_formatter = self.LogFormatter(use_color=False, detailed=True)
        file_handler.setFormatter(file_formatter)
        self.logger.addHandler(file_handler)
        
        # Handler para erros
        error_log_path = os.path.join(self.log_dir, f"{self.name}.error.log")
        error_handler = logging.handlers.RotatingFileHandler(
            error_log_path,
            maxBytes=LeonardoConstants.Defaults.MAX_LOG_SIZE,
            backupCount=LeonardoConstants.Defaults.LOG_BACKUP_COUNT,
            encoding='utf-8'
        )
        error_handler.setLevel(logging.ERROR)
        error_formatter = self.LogFormatter(use_color=False, detailed=True)
        error_handler.setFormatter(error_formatter)
        self.logger.addHandler(error_handler)
        
        # Handler para auditoria
        audit_log_path = os.path.join(self.log_dir, f"{self.name}.audit.log")
        audit_handler = logging.handlers.RotatingFileHandler(
            audit_log_path,
            maxBytes=LeonardoConstants.Defaults.MAX_LOG_SIZE,
            backupCount=LeonardoConstants.Defaults.LOG_BACKUP_COUNT,
            encoding='utf-8'
        )
        audit_handler.setLevel(self.LogLevel.AUDIT)
        audit_formatter = logging.Formatter(
            '%(asctime)s | %(levelname)s | %(name)s | %(message)s | User: %(user)s | IP: %(ip)s | Action: %(action)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        audit_handler.setFormatter(audit_formatter)
        self.logger.addHandler(audit_handler)
        
        # Handler para segurança
        security_log_path = os.path.join(self.log_dir, f"{self.name}.security.log")
        security_handler = logging.handlers.RotatingFileHandler(
            security_log_path,
            maxBytes=LeonardoConstants.Defaults.MAX_LOG_SIZE,
            backupCount=LeonardoConstants.Defaults.LOG_BACKUP_COUNT,
            encoding='utf-8'
        )
        security_handler.setLevel(self.LogLevel.SECURITY)
        security_formatter = logging.Formatter(
            '%(asctime)s | SECURITY | %(name)s | %(message)s | Threat: %(threat_level)s | Source: %(source_ip)s | Details: %(details)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        security_handler.setFormatter(security_formatter)
        self.logger.addHandler(security_handler)
        
        # Handler syslog para sistemas Unix
        if hasattr(logging.handlers, 'SysLogHandler') and os.name != 'nt':
            try:
                syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
                syslog_handler.setLevel(logging.WARNING)
                syslog_formatter = logging.Formatter('LeonardoOSINT[%(process)d]: %(levelname)s %(message)s')
                syslog_handler.setFormatter(syslog_formatter)
                self.logger.addHandler(syslog_handler)
            except Exception as e:
                self.logger.warning(f"Não foi possível configurar syslog: {e}")
        
        # Handler para Windows Event Log
        if os.name == 'nt':
            try:
                import win32evtlogutil
                import win32evtlog
                
                win_event_handler = logging.handlers.NTEventLogHandler("LeonardoOSINT")
                win_event_handler.setLevel(logging.ERROR)
                self.logger.addHandler(win_event_handler)
            except ImportError:
                pass
        
        # Handler para notificações em tempo real (WebSocket)
        self.websocket_handler = None
    
    def add_websocket_handler(self, websocket_server):
        """Adiciona handler para WebSocket"""
        class WebSocketHandler(logging.Handler):
            def emit(self, record):
                try:
                    msg = self.format(record)
                    websocket_server.broadcast({
                        'type': 'log',
                        'timestamp': datetime.datetime.now().isoformat(),
                        'level': record.levelname,
                        'message': msg,
                        'module': record.name
                    })
                except Exception:
                    pass
        
        self.websocket_handler = WebSocketHandler()
        self.websocket_handler.setLevel(self.level)
        self.websocket_handler.setFormatter(self.LogFormatter(use_color=False, detailed=False))
        self.logger.addHandler(self.websocket_handler)
    
    def log_audit(self, message, user="system", ip="127.0.0.1", action="system"):
        """Registra evento de auditoria"""
        extra = {'user': user, 'ip': ip, 'action': action}
        self.logger.log(self.LogLevel.AUDIT, message, extra=extra)
    
    def log_security(self, message, threat_level="medium", source_ip="unknown", details=""):
        """Registra evento de segurança"""
        extra = {'threat_level': threat_level, 'source_ip': source_ip, 'details': details}
        self.logger.log(self.LogLevel.SECURITY, message, extra=extra)
    
    def log_performance(self, operation, duration_ms, details=None):
        """Registra métrica de performance"""
        if details is None:
            details = {}
        
        message = f"Performance: {operation} took {duration_ms:.2f}ms"
        if details:
            message += f" | Details: {details}"
        
        self.logger.log(self.LogLevel.TRACE, message)
    
    def log_api_call(self, api_name, endpoint, status_code, duration_ms, parameters=None):
        """Registra chamada de API"""
        if parameters is None:
            parameters = {}
        
        message = f"API Call: {api_name} - {endpoint} - Status: {status_code} - Time: {duration_ms:.2f}ms"
        if parameters:
            # Esconde parâmetros sensíveis
            safe_params = {}
            for key, value in parameters.items():
                if any(sensitive in key.lower() for sensitive in ['key', 'token', 'secret', 'password', 'auth']):
                    safe_params[key] = '***HIDDEN***'
                else:
                    safe_params[key] = str(value)[:100]  # Limita tamanho
            
            message += f" | Params: {safe_params}"
        
        self.logger.log(self.LogLevel.DEBUG, message)
    
    def log_data_collection(self, source, data_type, item_count, details=None):
        """Registra coleta de dados"""
        if details is None:
            details = {}
        
        message = f"Data Collection: {source} - Type: {data_type} - Items: {item_count}"
        if details:
            message += f" | Details: {details}"
        
        self.logger.log(self.LogLevel.INFO, message)
    
    def get_log_files(self):
        """Retorna lista de arquivos de log"""
        log_files = []
        for handler in self.logger.handlers:
            if isinstance(handler, logging.handlers.RotatingFileHandler):
                log_files.append(handler.baseFilename)
        
        return log_files
    
    def cleanup_old_logs(self, days_to_keep=30):
        """Limpa logs antigos"""
        cutoff_time = time.time() - (days_to_keep * 86400)
        log_dir = self.log_dir
        
        for filename in os.listdir(log_dir):
            filepath = os.path.join(log_dir, filename)
            if os.path.isfile(filepath):
                if os.path.getmtime(filepath) < cutoff_time:
                    try:
                        os.remove(filepath)
                        self.logger.info(f"Removido log antigo: {filename}")
                    except Exception as e:
                        self.logger.error(f"Erro ao remover log {filename}: {e}")
    
    def set_level(self, level):
        """Define o nível de logging"""
        self.level = level
        self.logger.setLevel(level)
        for handler in self.logger.handlers:
            handler.setLevel(level)
    
    def get_logger(self, module_name=None):
        """Retorna um logger para um módulo específico"""
        if module_name:
            full_name = f"{self.name}.{module_name}"
        else:
            full_name = self.name
        
        return logging.getLogger(full_name)

# ============================================================================
# SISTEMA DE CONFIGURAÇÃO (1.200+ linhas)
# ============================================================================

class LeonardoConfig:
    """Sistema de configuração avançado com múltiplos backends"""
    
    class ConfigSection(enum.Enum):
        """Seções de configuração"""
        GENERAL = "General"
        NETWORK = "Network"
        SECURITY = "Security"
        DATABASE = "Database"
        API_KEYS = "API_Keys"
        MODULES = "Modules"
        UI = "UI"
        LOGGING = "Logging"
        PERFORMANCE = "Performance"
        UPDATES = "Updates"
        NOTIFICATIONS = "Notifications"
        INTEGRATIONS = "Integrations"
        AUTOMATION = "Automation"
        BACKUP = "Backup"
        LEGAL = "Legal"
        ADVANCED = "Advanced"
    
    class ConfigBackend(enum.Enum):
        """Backends de configuração suportados"""
        INI_FILE = "ini"
        JSON_FILE = "json"
        YAML_FILE = "yaml"
        SQLITE = "sqlite"
        ENVIRONMENT = "env"
        ETCD = "etcd"
        CONSUL = "consul"
        AWS_SM = "aws_secrets"
        AZURE_KV = "azure_kv"
        HASHICORP_VAULT = "vault"
        MEMORY = "memory"
    
    def __init__(self, config_file=None, backend=ConfigBackend.INI_FILE):
        """Inicializa o sistema de configuração"""
        self.config_file = config_file or LeonardoConstants.Defaults.CONFIG_FILE
        self.backend = backend
        self.config_data = {}
        self.secrets = {}
        self.watchers = {}
        self.validators = {}
        
        # Configurações padrão
        self.default_config = self._get_default_config()
        
        # Inicializa backend
        self._init_backend()
        
        # Carrega configurações
        self.load()
        
        # Configura validações
        self._setup_validators()
        
        # Configura watchers
        self._setup_watchers()
    
    def _get_default_config(self):
        """Retorna configurações padrão"""
        return {
            self.ConfigSection.GENERAL.value: {
                'version': LeonardoConstants.VERSION,
                'author': LeonardoConstants.AUTHOR,
                'language': 'en',
                'timezone': LeonardoConstants.Defaults.DEFAULT_TIMEZONE,
                'locale': LeonardoConstants.Defaults.DEFAULT_LOCALE,
                'encoding': LeonardoConstants.Defaults.DEFAULT_ENCODING,
                'working_directory': os.getcwd(),
                'temp_directory': LeonardoConstants.Defaults.TEMP_DIR,
                'enable_telemetry': LeonardoConstants.Defaults.TELEMETRY_ENABLED,
                'enable_error_reporting': LeonardoConstants.Defaults.ERROR_REPORTING,
                'enable_crash_reports': LeonardoConstants.Defaults.CRASH_REPORTS,
                'legal_accepted': False
            },
            self.ConfigSection.NETWORK.value: {
                'timeout': LeonardoConstants.Defaults.TIMEOUT,
                'max_retries': LeonardoConstants.Defaults.MAX_RETRIES,
                'concurrent_workers': LeonardoConstants.Defaults.CONCURRENT_WORKERS,
                'rate_limit_delay': LeonardoConstants.Defaults.RATE_LIMIT_DELAY,
                'user_agent_rotation': LeonardoConstants.Defaults.USER_AGENT_ROTATION,
                'random_delay_min': LeonardoConstants.Defaults.RANDOM_DELAY_MIN,
                'random_delay_max': LeonardoConstants.Defaults.RANDOM_DELAY_MAX,
                'respect_robots_txt': LeonardoConstants.Defaults.RESPECT_ROBOTS_TXT,
                'http_proxy': LeonardoConstants.Defaults.HTTP_PROXY,
                'https_proxy': LeonardoConstants.Defaults.HTTPS_PROXY,
                'socks_proxy': LeonardoConstants.Defaults.SOCKS_PROXY,
                'no_proxy': LeonardoConstants.Defaults.NO_PROXY,
                'ssl_verify': LeonardoConstants.Defaults.SSL_VERIFY,
                'ssl_cert_file': LeonardoConstants.Defaults.SSL_CERT_FILE,
                'ssl_key_file': LeonardoConstants.Defaults.SSL_KEY_FILE,
                'ssl_ca_bundle': LeonardoConstants.Defaults.SSL_CA_BUNDLE,
                'dns_servers': '8.8.8.8,8.8.4.4,1.1.1.1',
                'enable_ipv6': True,
                'enable_doh': False,
                'doh_servers': 'https://cloudflare-dns.com/dns-query,https://dns.google/dns-query'
            },
            self.ConfigSection.SECURITY.value: {
                'encryption_enabled': True,
                'encryption_algorithm': 'AES-256-GCM',
                'hash_algorithm': 'SHA-256',
                'session_timeout': 3600,
                'max_login_attempts': 5,
                'lockout_duration': 900,
                'password_min_length': 12,
                'require_complex_password': True,
                'enable_2fa': False,
                '2fa_method': 'totp',
                'api_key_rotation_days': 90,
                'audit_log_enabled': True,
                'security_log_enabled': True,
                'threat_intel_enabled': True,
                'enable_firewall': False,
                'firewall_rules': '',
                'enable_ids': False,
                'ids_sensitivity': 'medium',
                'data_retention_days': 365,
                'secure_deletion': True,
                'deletion_passes': 3
            },
            self.ConfigSection.DATABASE.value: {
                'db_path': LeonardoConstants.Defaults.DB_PATH,
                'db_engine': 'sqlite',
                'db_host': 'localhost',
                'db_port': 0,
                'db_name': 'leonardo_osint',
                'db_user': '',
                'db_password': '',
                'max_db_size': LeonardoConstants.Defaults.MAX_DB_SIZE,
                'backup_enabled': True,
                'backup_interval_hours': 24,
                'backup_retention_days': LeonardoConstants.Defaults.BACKUP_RETENTION_DAYS,
                'enable_encryption': True,
                'compression_enabled': True,
                'vacuum_on_exit': True,
                'query_timeout': 30,
                'connection_pool_size': 10,
                'enable_replication': False,
                'replica_hosts': '',
                'enable_sharding': False,
                'shard_count': 4
            },
            self.ConfigSection.API_KEYS.value: {
                'shodan_api_key': '',
                'virustotal_api_key': '',
                'censys_api_id': '',
                'censys_api_secret': '',
                'securitytrails_api_key': '',
                'whoisxmlapi_key': '',
                'hunter_api_key': '',
                'clearbit_api_key': '',
                'abuseipdb_api_key': '',
                'binaryedge_api_key': '',
                'greynoise_api_key': '',
                'onyphe_api_key': '',
                'pulsedive_api_key': '',
                'alienvault_otx_key': '',
                'urlscan_api_key': '',
                'publicwww_api_key': '',
                'spyonweb_api_key': '',
                'builtwith_api_key': '',
                'wappalyzer_api_key': '',
                'moz_access_id': '',
                'moz_secret_key': '',
                'google_safe_browsing_key': '',
                'google_pagespeed_key': '',
                'ssllabs_api_key': '',
                'hibp_api_key': '',
                'dehashed_email': '',
                'dehashed_api_key': '',
                'twitter_api_key': '',
                'twitter_api_secret': '',
                'twitter_access_token': '',
                'twitter_access_secret': '',
                'instagram_username': '',
                'instagram_password': '',
                'facebook_email': '',
                'facebook_password': '',
                'linkedin_email': '',
                'linkedin_password': '',
                'github_token': '',
                'reddit_client_id': '',
                'reddit_client_secret': '',
                'telegram_bot_token': '',
                'discord_bot_token': '',
                'slack_bot_token': '',
                'openai_api_key': '',
                'google_ai_key': '',
                'anthropic_api_key': '',
                'cohere_api_key': '',
                'huggingface_token': '',
                'replicate_api_token': ''
            },
            self.ConfigSection.MODULES.value: {
                'enable_social_media': True,
                'enable_domain_intel': True,
                'enable_email_intel': True,
                'enable_image_intel': True,
                'enable_darkweb': False,
                'enable_phone_intel': True,
                'enable_geolocation': True,
                'enable_blockchain': True,
                'enable_vulnerability': True,
                'enable_ai_analysis': True,
                'enable_network_scan': True,
                'enable_forensics': True,
                'enable_malware_analysis': False,
                'enable_threat_intel': True,
                'enable_osint_framework': True,
                'enable_automated_recon': True,
                'enable_reporting': True,
                'enable_visualization': True,
                'enable_automation': True,
                'enable_integrations': True,
                'module_timeout': 300,
                'max_module_memory': 1024,
                'module_concurrency': 5,
                'enable_module_cache': True,
                'module_cache_ttl': 3600,
                'enable_module_updates': True,
                'module_update_check': 'daily'
            },
            self.ConfigSection.UI.value: {
                'theme': LeonardoConstants.Defaults.COLOR_THEME,
                'refresh_rate': LeonardoConstants.Defaults.UI_REFRESH_RATE,
                'enable_animations': True,
                'font_size': 12,
                'font_family': 'monospace',
                'enable_syntax_highlighting': True,
                'color_scheme': 'dracula',
                'enable_tooltips': True,
                'show_line_numbers': True,
                'wrap_text': False,
                'tab_size': 4,
                'enable_autocomplete': True,
                'autocomplete_delay': 300,
                'enable_live_preview': True,
                'split_panes': True,
                'pane_orientation': 'horizontal',
                'enable_multiple_windows': True,
                'window_transparency': 0.95,
                'enable_fullscreen': False,
                'enable_hotkeys': True,
                'hotkey_config': 'default',
                'enable_gestures': False,
                'enable_voice_control': False,
                'enable_eye_tracking': False,
                'accessibility_mode': False,
                'high_contrast_mode': False,
                'screen_reader_enabled': False
            },
            self.ConfigSection.LOGGING.value: {
                'log_level': LeonardoConstants.Defaults.LOG_LEVEL,
                'log_directory': LeonardoConstants.Defaults.LOG_DIR,
                'max_log_size': LeonardoConstants.Defaults.MAX_LOG_SIZE,
                'log_backup_count': LeonardoConstants.Defaults.LOG_BACKUP_COUNT,
                'enable_console_logging': True,
                'enable_file_logging': True,
                'enable_audit_logging': True,
                'enable_security_logging': True,
                'enable_performance_logging': True,
                'enable_syslog': False,
                'syslog_server': '',
                'syslog_port': 514,
                'enable_websocket_logging': False,
                'websocket_port': 8765,
                'log_format': 'detailed',
                'enable_log_rotation': True,
                'log_rotation_time': 'midnight',
                'enable_log_compression': True,
                'compression_level': 6,
                'enable_log_encryption': False,
                'log_encryption_key': '',
                'enable_log_analytics': True,
                'log_retention_days': 90,
                'enable_log_archiving': True,
                'archive_format': 'zip'
            },
            self.ConfigSection.PERFORMANCE.value: {
                'enable_caching': True,
                'cache_directory': LeonardoConstants.Defaults.CACHE_DIR,
                'cache_ttl': LeonardoConstants.Defaults.CACHE_TTL,
                'max_cache_size': 1024 * 1024 * 1024,  # 1GB
                'cache_eviction_policy': 'lru',
                'enable_memory_cache': True,
                'memory_cache_size': 1024 * 1024 * 512,  # 512MB
                'enable_disk_cache': True,
                'disk_cache_size': 1024 * 1024 * 2048,  # 2GB
                'enable_query_cache': True,
                'query_cache_size': 1000,
                'enable_result_cache': True,
                'result_cache_ttl': 3600,
                'enable_compression': True,
                'compression_level': 6,
                'enable_parallel_processing': True,
                'max_workers': multiprocessing.cpu_count() * 2,
                'enable_batch_processing': True,
                'batch_size': 100,
                'enable_streaming': True,
                'stream_buffer_size': 8192,
                'enable_prefetching': True,
                'prefetch_count': 10,
                'enable_lazy_loading': True,
                'lazy_load_threshold': 1000,
                'enable_indexing': True,
                'index_refresh_interval': 300,
                'enable_optimization': True,
                'optimization_level': 'O2'
            },
            self.ConfigSection.UPDATES.value: {
                'automatic_updates': LeonardoConstants.Defaults.AUTOMATIC_UPDATES,
                'update_check_interval': LeonardoConstants.Defaults.UPDATE_CHECK_INTERVAL,
                'update_channel': LeonardoConstants.Defaults.UPDATE_CHANNEL,
                'enable_prereleases': False,
                'enable_security_updates': True,
                'enable_module_updates': True,
                'update_notification': True,
                'auto_download_updates': False,
                'auto_install_updates': False,
                'update_verification': True,
                'verify_signatures': True,
                'backup_before_update': True,
                'rollback_on_failure': True,
                'update_source': 'github',
                'custom_update_url': '',
                'proxy_for_updates': '',
                'update_timeout': 300,
                'retry_failed_updates': True,
                'max_update_retries': 3,
                'schedule_updates': False,
                'update_schedule': '0 2 * * *',  # 2 AM daily
                'notify_on_update': True,
                'notification_method': 'email'
            },
            self.ConfigSection.NOTIFICATIONS.value: {
                'notifications_enabled': LeonardoConstants.Defaults.NOTIFICATION_ENABLED,
                'notification_service': LeonardoConstants.Defaults.NOTIFICATION_SERVICE,
                'notification_email': LeonardoConstants.Defaults.NOTIFICATION_EMAIL,
                'notification_webhook': LeonardoConstants.Defaults.NOTIFICATION_WEBHOOK,
                'enable_desktop_notifications': True,
                'enable_email_notifications': True,
                'enable_sms_notifications': False,
                'enable_push_notifications': False,
                'enable_webhook_notifications': True,
                'enable_slack_notifications': False,
                'enable_telegram_notifications': False,
                'enable_discord_notifications': False,
                'enable_matrix_notifications': False,
                'enable_custom_notifications': False,
                'notification_threshold': 'medium',
                'notification_cooldown': 300,
                'enable_digest_mode': True,
                'digest_interval': 3600,
                'notification_format': 'html',
                'enable_rich_notifications': True,
                'notification_sound': True,
                'sound_file': 'default',
                'enable_vibration': False,
                'enable_flash': False,
                'notification_priority': 'normal',
                'group_notifications': True,
                'max_notifications': 100,
                'notification_retention_days': 30,
                'enable_feedback': True,
                'feedback_url': ''
            },
            self.ConfigSection.INTEGRATIONS.value: {
                'enable_slack': False,
                'slack_webhook_url': '',
                'slack_bot_token': '',
                'slack_channel': '',
                'enable_teams': False,
                'teams_webhook_url': '',
                'enable_discord': False,
                'discord_webhook_url': '',
                'discord_bot_token': '',
                'discord_channel': '',
                'enable_telegram': False,
                'telegram_bot_token': '',
                'telegram_chat_id': '',
                'enable_whatsapp': False,
                'whatsapp_api_key': '',
                'whatsapp_phone_number': '',
                'enable_email': False,
                'smtp_server': '',
                'smtp_port': 587,
                'smtp_username': '',
                'smtp_password': '',
                'smtp_tls': True,
                'smtp_ssl': False,
                'from_email': '',
                'to_emails': '',
                'enable_jira': False,
                'jira_url': '',
                'jira_username': '',
                'jira_api_token': '',
                'jira_project': '',
                'jira_issue_type': 'Task',
                'enable_service_now': False,
                'servicenow_url': '',
                'servicenow_username': '',
                'servicenow_password': '',
                'servicenow_table': 'incident',
                'enable_webex': False,
                'webex_webhook_url': '',
                'webex_bot_token': '',
                'enable_mattermost': False,
                'mattermost_webhook_url': '',
                'mattermost_channel': '',
                'enable_rocket_chat': False,
                'rocketchat_webhook_url': '',
                'rocketchat_channel': '',
                'enable_zapier': False,
                'zapier_webhook_url': '',
                'enable_ifttt': False,
                'ifttt_webhook_url': '',
                'ifttt_event_name': '',
                'enable_power_automate': False,
                'powerautomate_webhook_url': '',
                'enable_custom_webhook': False,
                'custom_webhook_url': '',
                'custom_webhook_method': 'POST',
                'custom_webhook_headers': '{}',
                'custom_webhook_format': 'json'
            },
            self.ConfigSection.AUTOMATION.value: {
                'enable_automation': True,
                'automation_engine': 'celery',
                'celery_broker_url': 'redis://localhost:6379/0',
                'celery_result_backend': 'redis://localhost:6379/0',
                'enable_scheduling': True,
                'scheduler_type': 'apscheduler',
                'max_concurrent_jobs': 10,
                'job_timeout': 3600,
                'job_retry_count': 3,
                'job_retry_delay': 60,
                'enable_workflows': True,
                'workflow_engine': 'prefect',
                'prefect_api_url': 'http://localhost:4200/api',
                'enable_triggers': True,
                'trigger_types': 'time,event,file,api',
                'enable_conditions': True,
                'condition_engine': 'drools',
                'enable_actions': True,
                'action_types': 'email,webhook,script,api',
                'enable_monitoring': True,
                'monitoring_interval': 60,
                'enable_alerts': True,
                'alert_conditions': 'failure,timeout,resource',
                'enable_logging': True,
                'log_level': 'INFO',
                'enable_metrics': True,
                'metrics_backend': 'prometheus',
                'prometheus_url': 'http://localhost:9090',
                'enable_tracing': True,
                'tracing_backend': 'jaeger',
                'jaeger_url': 'http://localhost:16686',
                'enable_audit': True,
                'audit_log_path': 'logs/automation_audit.log'
            },
            self.ConfigSection.BACKUP.value: {
                'backup_enabled': True,
                'backup_type': 'full',
                'backup_schedule': '0 2 * * *',  # 2 AM daily
                'backup_retention_days': LeonardoConstants.Defaults.BACKUP_RETENTION_DAYS,
                'backup_compression': True,
                'compression_level': 6,
                'backup_encryption': True,
                'encryption_algorithm': 'AES-256-GCM',
                'encryption_key': '',
                'backup_destination': 'local',
                'local_backup_path': 'backups',
                's3_backup_bucket': '',
                's3_access_key': '',
                's3_secret_key': '',
                's3_region': '',
                's3_endpoint': '',
                'azure_backup_container': '',
                'azure_connection_string': '',
                'gcs_backup_bucket': '',
                'gcs_credentials_file': '',
                'gcs_project_id': '',
                'ftp_backup_server': '',
                'ftp_username': '',
                'ftp_password': '',
                'ftp_port': 21,
                'sftp_backup_server': '',
                'sftp_username': '',
                'sftp_password': '',
                'sftp_port': 22,
                'webdav_backup_url': '',
                'webdav_username': '',
                'webdav_password': '',
                'enable_incremental': True,
                'incremental_interval': 3600,
                'enable_differential': True,
                'differential_interval': 86400,
                'verify_backups': True,
                'verification_method': 'checksum',
                'enable_restore': True,
                'restore_test_interval': 7,
                'enable_backup_monitoring': True,
                'monitoring_webhook': '',
                'backup_timeout': 7200,
                'max_backup_retries': 3
            },
            self.ConfigSection.LEGAL.value: {
                'legal_disclaimer': LeonardoConstants.Defaults.LEGAL_DISCLAIMER,
                'ethical_guidelines': LeonardoConstants.Defaults.ETHICAL_GUIDELINES,
                'terms_accepted': False,
                'privacy_policy_accepted': False,
                'data_processing_consent': False,
                'compliance_framework': 'gdpr',
                'data_retention_policy': 'compliant',
                'enable_audit_trail': True,
                'audit_trail_retention': 3650,
                'enable_consent_management': True,
                'consent_storage_duration': 3650,
                'enable_data_protection': True,
                'data_protection_method': 'encryption',
                'enable_privacy_by_design': True,
                'privacy_assessment_frequency': 90,
                'enable_breach_notification': True,
                'breach_notification_time': 72,
                'enable_dsar_management': True,
                'dsar_response_time': 30,
                'enable_data_mapping': True,
                'data_mapping_refresh': 180,
                'enable_risk_assessment': True,
                'risk_assessment_frequency': 180,
                'enable_compliance_reporting': True,
                'compliance_report_frequency': 365,
                'enable_third_party_audit': False,
                'third_party_auditor': '',
                'audit_frequency': 365,
                'enable_certification': False,
                'certification_type': '',
                'certification_body': '',
                'certification_expiry': '',
                'enable_insurance': False,
                'insurance_provider': '',
                'insurance_policy': '',
                'insurance_expiry': ''
            },
            self.ConfigSection.ADVANCED.value: {
                'debug_mode': False,
                'developer_mode': False,
                'experimental_features': False,
                'enable_profiling': False,
                'profiling_output': 'profiles',
                'enable_benchmarking': False,
                'benchmark_iterations': 1000,
                'enable_fuzzing': False,
                'fuzzing_target': '',
                'enable_coverage': False,
                'coverage_report': 'coverage.xml',
                'enable_linting': False,
                'linter_rules': 'pylint',
                'enable_type_checking': False,
                'type_checker': 'mypy',
                'enable_testing': False,
                'test_framework': 'pytest',
                'test_directory': 'tests',
                'enable_documentation': False,
                'docs_generator': 'sphinx',
                'docs_output': 'docs',
                'enable_i18n': False,
                'default_language': 'en',
                'supported_languages': 'en,pt,es,fr,de',
                'enable_a11y': False,
                'a11y_standard': 'wcag2aa',
                'enable_security_headers': True,
                'security_headers_config': 'strict',
                'enable_csp': True,
                'csp_policy': "default-src 'self'",
                'enable_hsts': True,
                'hsts_max_age': 31536000,
                'enable_cors': False,
                'cors_origins': '*',
                'enable_rate_limiting': True,
                'rate_limit_requests': 100,
                'rate_limit_period': 60,
                'enable_cache_control': True,
                'cache_control_max_age': 3600,
                'enable_compression': True,
                'compression_level': 6,
                'enable_gzip': True,
                'gzip_level': 6,
                'enable_brotli': False,
                'brotli_quality': 4,
                'enable_minification': True,
                'minifier': 'htmlmin',
                'enable_cdn': False,
                'cdn_provider': '',
                'cdn_url': '',
                'enable_monitoring': True,
                'monitoring_tool': 'prometheus',
                'prometheus_url': 'http://localhost:9090',
                'enable_logging': True,
                'log_aggregator': 'loki',
                'loki_url': 'http://localhost:3100',
                'enable_tracing': True,
                'tracing_backend': 'jaeger',
                'jaeger_url': 'http://localhost:16686',
                'enable_alerting': True,
                'alert_manager': 'alertmanager',
                'alertmanager_url': 'http://localhost:9093'
            }
        }
    
    def _init_backend(self):
        """Inicializa o backend de configuração"""
        try:
            if self.backend == self.ConfigBackend.INI_FILE:
                self.backend_instance = configparser.ConfigParser()
                self.backend_instance.optionxform = str  # Preserva case
            elif self.backend == self.ConfigBackend.JSON_FILE:
                import json
                self.backend_instance = json
            elif self.backend == self.ConfigBackend.YAML_FILE:
                try:
                    import yaml
                    self.backend_instance = yaml
                except ImportError:
                    raise ImportError("PyYAML não está instalado. Use: pip install PyYAML")
            elif self.backend == self.ConfigBackend.SQLITE:
                import sqlite3
                self.backend_instance = sqlite3
            elif self.backend == self.ConfigBackend.ENVIRONMENT:
                import os
                self.backend_instance = os.environ
            elif self.backend == self.ConfigBackend.ETCD:
                try:
                    import etcd3
                    self.backend_instance = etcd3
                except ImportError:
                    raise ImportError("etcd3 não está instalado. Use: pip install etcd3")
            elif self.backend == self.ConfigBackend.CONSUL:
                try:
                    import consul
                    self.backend_instance = consul
                except ImportError:
                    raise ImportError("python-consul não está instalado. Use: pip install python-consul")
            elif self.backend == self.ConfigBackend.AWS_SM:
                try:
                    import boto3
                    self.backend_instance = boto3
                except ImportError:
                    raise ImportError("boto3 não está instalado. Use: pip install boto3")
            elif self.backend == self.ConfigBackend.AZURE_KV:
                try:
                    from azure.keyvault.secrets import SecretClient
                    from azure.identity import DefaultAzureCredential
                    self.backend_instance = (SecretClient, DefaultAzureCredential)
                except ImportError:
                    raise ImportError("azure-keyvault e azure-identity não estão instalados. Use: pip install azure-keyvault-secrets azure-identity")
            elif self.backend == self.ConfigBackend.HASHICORP_VAULT:
                try:
                    import hvac
                    self.backend_instance = hvac
                except ImportError:
                    raise ImportError("hvac não está instalado. Use: pip install hvac")
            elif self.backend == self.ConfigBackend.MEMORY:
                self.backend_instance = {}
            else:
                raise ValueError(f"Backend não suportado: {self.backend}")
        except Exception as e:
            print(f"Erro ao inicializar backend {self.backend}: {e}")
            # Fallback para INI
            self.backend = self.ConfigBackend.INI_FILE
            self.backend_instance = configparser.ConfigParser()
            self.backend_instance.optionxform = str
    
    def load(self, config_file=None):
        """Carrega configurações do arquivo"""
        if config_file:
            self.config_file = config_file
        
        try:
            if self.backend == self.ConfigBackend.INI_FILE:
                if os.path.exists(self.config_file):
                    self.backend_instance.read(self.config_file, encoding='utf-8')
                    self._parse_ini_config()
                else:
                    self._create_default_config()
            
            elif self.backend == self.ConfigBackend.JSON_FILE:
                if os.path.exists(self.config_file):
                    with open(self.config_file, 'r', encoding='utf-8') as f:
                        self.config_data = self.backend_instance.load(f)
                else:
                    self._create_default_config()
            
            elif self.backend == self.ConfigBackend.YAML_FILE:
                if os.path.exists(self.config_file):
                    with open(self.config_file, 'r', encoding='utf-8') as f:
                        self.config_data = self.backend_instance.safe_load(f)
                else:
                    self._create_default_config()
            
            elif self.backend == self.ConfigBackend.SQLITE:
                if os.path.exists(self.config_file):
                    conn = self.backend_instance.connect(self.config_file)
                    cursor = conn.cursor()
                    cursor.execute("SELECT section, key, value FROM config")
                    rows = cursor.fetchall()
                    for section, key, value in rows:
                        if section not in self.config_data:
                            self.config_data[section] = {}
                        self.config_data[section][key] = value
                    conn.close()
                else:
                    self._create_default_config()
            
            elif self.backend == self.ConfigBackend.ENVIRONMENT:
                # Carrega variáveis de ambiente com prefixo LEONARDO_
                for key, value in self.backend_instance.items():
                    if key.startswith('LEONARDO_'):
                        parts = key[9:].lower().split('__')
                        if len(parts) >= 2:
                            section = parts[0]
                            config_key = '__'.join(parts[1:])
                            if section not in self.config_data:
                                self.config_data[section] = {}
                            self.config_data[section][config_key] = value
            
            # Outros backends...
            
            self._validate_config()
            self._encrypt_sensitive_data()
            
            print(f"Configurações carregadas de {self.config_file}")
            return True
            
        except Exception as e:
            print(f"Erro ao carregar configurações: {e}")
            self._create_default_config()
            return False
    
    def save(self, config_file=None):
        """Salva configurações no arquivo"""
        if config_file:
            self.config_file = config_file
        
        try:
            self._decrypt_sensitive_data()
            self._validate_config()
            
            if self.backend == self.ConfigBackend.INI_FILE:
                # Atualiza backend_instance com config_data
                for section, options in self.config_data.items():
                    if not self.backend_instance.has_section(section):
                        self.backend_instance.add_section(section)
                    for key, value in options.items():
                        self.backend_instance.set(section, key, str(value))
                
                with open(self.config_file, 'w', encoding='utf-8') as f:
                    self.backend_instance.write(f)
            
            elif self.backend == self.ConfigBackend.JSON_FILE:
                with open(self.config_file, 'w', encoding='utf-8') as f:
                    self.backend_instance.dump(self.config_data, f, indent=2, ensure_ascii=False)
            
            elif self.backend == self.ConfigBackend.YAML_FILE:
                with open(self.config_file, 'w', encoding='utf-8') as f:
                    self.backend_instance.dump(self.config_data, f, default_flow_style=False, allow_unicode=True)
            
            elif self.backend == self.ConfigBackend.SQLITE:
                conn = self.backend_instance.connect(self.config_file)
                cursor = conn.cursor()
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS config (
                        section TEXT,
                        key TEXT,
                        value TEXT,
                        PRIMARY KEY (section, key)
                    )
                """)
                
                cursor.execute("DELETE FROM config")
                for section, options in self.config_data.items():
                    for key, value in options.items():
                        cursor.execute(
                            "INSERT INTO config (section, key, value) VALUES (?, ?, ?)",
                            (section, key, str(value))
                        )
                conn.commit()
                conn.close()
            
            self._encrypt_sensitive_data()
            print(f"Configurações salvas em {self.config_file}")
            return True
            
        except Exception as e:
            print(f"Erro ao salvar configurações: {e}")
            return False
    
    def _create_default_config(self):
        """Cria configuração padrão"""
        self.config_data = self.default_config.copy()
        self.save()
    
    def _parse_ini_config(self):
        """Converte INI para config_data"""
        self.config_data = {}
        for section in self.backend_instance.sections():
            self.config_data[section] = {}
            for key in self.backend_instance.options(section):
                value = self.backend_instance.get(section, key)
                self.config_data[section][key] = value
    
    def _setup_validators(self):
        """Configura validadores para cada configuração"""
        # Validadores básicos
        self.validators = {
            ('General', 'version'): self._validate_version,
            ('General', 'language'): self._validate_language,
            ('Network', 'timeout'): self._validate_positive_integer,
            ('Network', 'max_retries'): self._validate_positive_integer,
            ('Network', 'concurrent_workers'): self._validate_positive_integer,
            ('Security', 'session_timeout'): self._validate_positive_integer,
            ('Security', 'max_login_attempts'): self._validate_positive_integer,
            ('Security', 'lockout_duration'): self._validate_positive_integer,
            ('Database', 'max_db_size'): self._validate_positive_integer,
            ('Database', 'backup_retention_days'): self._validate_positive_integer,
            ('Modules', 'module_timeout'): self._validate_positive_integer,
            ('Modules', 'max_module_memory'): self._validate_positive_integer,
            ('Logging', 'max_log_size'): self._validate_positive_integer,
            ('Logging', 'log_backup_count'): self._validate_positive_integer,
            ('Performance', 'max_cache_size'): self._validate_positive_integer,
            ('Performance', 'memory_cache_size'): self._validate_positive_integer,
            ('Updates', 'update_check_interval'): self._validate_positive_integer,
            ('Backup', 'backup_retention_days'): self._validate_positive_integer,
            ('Legal', 'audit_trail_retention'): self._validate_positive_integer,
            ('Advanced', 'rate_limit_requests'): self._validate_positive_integer,
            ('Advanced', 'rate_limit_period'): self._validate_positive_integer,
        }
        
        # Validadores de tipo
        for section, options in self.default_config.items():
            for key, default_value in options.items():
                if isinstance(default_value, bool):
                    self.validators[(section, key)] = self._validate_boolean
                elif isinstance(default_value, int):
                    self.validators[(section, key)] = self._validate_integer
                elif isinstance(default_value, float):
                    self.validators[(section, key)] = self._validate_float
                elif isinstance(default_value, list):
                    self.validators[(section, key)] = self._validate_list
                elif isinstance(default_value, dict):
                    self.validators[(section, key)] = self._validate_dict
    
    def _setup_watchers(self):
        """Configura watchers para configurações importantes"""
        self.watchers = {
            ('Security', 'encryption_enabled'): self._on_encryption_changed,
            ('Security', 'enable_2fa'): self._on_2fa_changed,
            ('Network', 'ssl_verify'): self._on_ssl_verify_changed,
            ('Logging', 'log_level'): self._on_log_level_changed,
            ('Updates', 'automatic_updates'): self._on_updates_changed,
            ('Notifications', 'notifications_enabled'): self._on_notifications_changed,
        }
    
    def _validate_config(self):
        """Valida todas as configurações"""
        errors = []
        
        for (section, key), validator in self.validators.items():
            if section in self.config_data and key in self.config_data[section]:
                try:
                    value = self.config_data[section][key]
                    validator(value)
                except ValueError as e:
                    errors.append(f"{section}.{key}: {e}")
                except Exception as e:
                    errors.append(f"{section}.{key}: Erro de validação: {e}")
        
        if errors:
            raise ValueError(f"Erros de validação:\n" + "\n".join(errors))
    
    def _validate_version(self, value):
        """Valida versão"""
        if not re.match(r'^\d+\.\d+\.\d+$', str(value)):
            raise ValueError("Versão deve estar no formato X.Y.Z")
    
    def _validate_language(self, value):
        """Valida código de idioma"""
        valid_languages = ['en', 'pt', 'es', 'fr', 'de', 'it', 'ja', 'ko', 'zh']
        if value not in valid_languages:
            raise ValueError(f"Idioma inválido. Use: {', '.join(valid_languages)}")
    
    def _validate_positive_integer(self, value):
        """Valida inteiro positivo"""
        try:
            int_val = int(value)
            if int_val <= 0:
                raise ValueError("Deve ser um número positivo")
        except ValueError:
            raise ValueError("Deve ser um número inteiro")
    
    def _validate_integer(self, value):
        """Valida inteiro"""
        try:
            int(value)
        except ValueError:
            raise ValueError("Deve ser um número inteiro")
    
    def _validate_float(self, value):
        """Valida float"""
        try:
            float(value)
        except ValueError:
            raise ValueError("Deve ser um número")
    
    def _validate_boolean(self, value):
        """Valida booleano"""
        if isinstance(value, bool):
            return
        
        value_str = str(value).lower()
        if value_str not in ['true', 'false', 'yes', 'no', '1', '0', 'on', 'off']:
            raise ValueError("Deve ser um valor booleano (true/false)")
    
    def _validate_list(self, value):
        """Valida lista"""
        if not isinstance(value, (list, tuple, str)):
            raise ValueError("Deve ser uma lista ou string separada por vírgulas")
    
    def _validate_dict(self, value):
        """Valida dicionário"""
        if not isinstance(value, (dict, str)):
            raise ValueError("Deve ser um dicionário ou string JSON")
    
    def _encrypt_sensitive_data(self):
        """Criptografa dados sensíveis"""
        sensitive_keys = [
            ('API_Keys', 'shodan_api_key'),
            ('API_Keys', 'virustotal_api_key'),
            ('API_Keys', 'censys_api_secret'),
            ('API_Keys', 'securitytrails_api_key'),
            ('API_Keys', 'twitter_api_secret'),
            ('API_Keys', 'github_token'),
            ('API_Keys', 'openai_api_key'),
            ('Security', 'encryption_key'),
            ('Backup', 'encryption_key'),
            ('Integrations', 'smtp_password'),
            ('Integrations', 'jira_api_token'),
            ('Integrations', 'servicenow_password'),
            ('Backup', 's3_secret_key'),
            ('Backup', 'ftp_password'),
            ('Backup', 'sftp_password'),
            ('Backup', 'webdav_password'),
        ]
        
        encryption_enabled = self.get('Security', 'encryption_enabled', default=True)
        
        if encryption_enabled and hasattr(self, '_encryption_key'):
            for section, key in sensitive_keys:
                if section in self.config_data and key in self.config_data[section]:
                    value = self.config_data[section][key]
                    if value and not value.startswith('ENC:'):
                        encrypted = self._encrypt_value(value)
                        self.config_data[section][key] = f'ENC:{encrypted}'
    
    def _decrypt_sensitive_data(self):
        """Descriptografa dados sensíveis"""
        if hasattr(self, '_encryption_key'):
            for section in self.config_data:
                for key in self.config_data[section]:
                    value = self.config_data[section][key]
                    if isinstance(value, str) and value.startswith('ENC:'):
                        encrypted = value[4:]
                        try:
                            decrypted = self._decrypt_value(encrypted)
                            self.config_data[section][key] = decrypted
                        except Exception:
                            # Mantém criptografado se falhar
                            pass
    
    def _encrypt_value(self, value):
        """Criptografa um valor"""
        # Implementação simplificada - em produção use uma biblioteca de criptografia robusta
        import base64
        from cryptography.fernet import Fernet
        
        if not hasattr(self, '_fernet'):
            # Gera ou carrega chave
            key_file = '.encryption_key'
            if os.path.exists(key_file):
                with open(key_file, 'rb') as f:
                    key = f.read()
            else:
                key = Fernet.generate_key()
                with open(key_file, 'wb') as f:
                    f.write(key)
                os.chmod(key_file, 0o600)
            
            self._fernet = Fernet(key)
            self._encryption_key = key
        
        encrypted = self._fernet.encrypt(value.encode('utf-8'))
        return base64.urlsafe_b64encode(encrypted).decode('utf-8')
    
    def _decrypt_value(self, encrypted):
        """Descriptografa um valor"""
        import base64
        from cryptography.fernet import Fernet
        
        if not hasattr(self, '_fernet'):
            raise ValueError("Cifra não inicializada")
        
        encrypted_bytes = base64.urlsafe_b64decode(encrypted.encode('utf-8'))
        decrypted = self._fernet.decrypt(encrypted_bytes)
        return decrypted.decode('utf-8')
    
    def get(self, section, key, default=None):
        """Obtém um valor de configuração"""
        if section in self.config_data and key in self.config_data[section]:
            value = self.config_data[section][key]
            
            # Converte para tipo apropriado
            default_section = self.default_config.get(section, {})
            if key in default_section:
                default_type = type(default_section[key])
                if default_type == bool:
                    if isinstance(value, bool):
                        return value
                    value_str = str(value).lower()
                    return value_str in ['true', 'yes', '1', 'on']
                elif default_type == int:
                    try:
                        return int(value)
                    except (ValueError, TypeError):
                        return default
                elif default_type == float:
                    try:
                        return float(value)
                    except (ValueError, TypeError):
                        return default
                elif default_type == list:
                    if isinstance(value, (list, tuple)):
                        return list(value)
                    elif isinstance(value, str):
                        return [item.strip() for item in value.split(',') if item.strip()]
                    else:
                        return default
                elif default_type == dict:
                    if isinstance(value, dict):
                        return value
                    elif isinstance(value, str):
                        try:
                            import json
                            return json.loads(value)
                        except:
                            return default
                    else:
                        return default
            
            return value
        
        return default
    
    def set(self, section, key, value):
        """Define um valor de configuração"""
        if section not in self.config_data:
            self.config_data[section] = {}
        
        old_value = self.config_data[section].get(key)
        self.config_data[section][key] = value
        
        # Executa watcher se houver
        if (section, key) in self.watchers:
            try:
                self.watchers[(section, key)](old_value, value)
            except Exception as e:
                print(f"Erro no watcher para {section}.{key}: {e}")
        
        # Valida o novo valor
        if (section, key) in self.validators:
            try:
                self.validators[(section, key)](value)
            except ValueError as e:
                print(f"Aviso: valor inválido para {section}.{key}: {e}")
                # Reverte para valor antigo
                if old_value is not None:
                    self.config_data[section][key] = old_value
                else:
                    del self.config_data[section][key]
                raise
        
        return True
    
    def get_section(self, section):
        """Obtém uma seção inteira"""
        return self.config_data.get(section, {}).copy()
    
    def set_section(self, section, data):
        """Define uma seção inteira"""
        self.config_data[section] = data.copy()
        self._validate_config()
    
    def has_section(self, section):
        """Verifica se uma seção existe"""
        return section in self.config_data
    
    def has_key(self, section, key):
        """Verifica se uma chave existe"""
        return section in self.config_data and key in self.config_data[section]
    
    def remove_key(self, section, key):
        """Remove uma chave"""
        if section in self.config_data and key in self.config_data[section]:
            del self.config_data[section][key]
            return True
        return False
    
    def remove_section(self, section):
        """Remove uma seção"""
        if section in self.config_data:
            del self.config_data[section]
            return True
        return False
    
    def list_sections(self):
        """Lista todas as seções"""
        return list(self.config_data.keys())
    
    def list_keys(self, section):
        """Lista todas as chaves em uma seção"""
        if section in self.config_data:
            return list(self.config_data[section].keys())
        return []
    
    def export(self, format='json', file_path=None):
        """Exporta configurações"""
        if not file_path:
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            file_path = f"leonardo_config_export_{timestamp}.{format}"
        
        try:
            if format == 'json':
                import json
                with open(file_path, 'w', encoding='utf-8') as f:
                    json.dump(self.config_data, f, indent=2, ensure_ascii=False)
            
            elif format == 'yaml':
                import yaml
                with open(file_path, 'w', encoding='utf-8') as f:
                    yaml.dump(self.config_data, f, default_flow_style=False, allow_unicode=True)
            
            elif format == 'ini':
                config_parser = configparser.ConfigParser()
                config_parser.optionxform = str
                
                for section, options in self.config_data.items():
                    config_parser.add_section(section)
                    for key, value in options.items():
                        config_parser.set(section, key, str(value))
                
                with open(file_path, 'w', encoding='utf-8') as f:
                    config_parser.write(f)
            
            else:
                raise ValueError(f"Formato não suportado: {format}")
            
            print(f"Configurações exportadas para {file_path}")
            return file_path
            
        except Exception as e:
            print(f"Erro ao exportar configurações: {e}")
            return None
    
    def import_config(self, file_path, merge=True):
        """Importa configurações de um arquivo"""
        try:
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"Arquivo não encontrado: {file_path}")
            
            ext = os.path.splitext(file_path)[1].lower()
            
            if ext == '.json':
                import json
                with open(file_path, 'r', encoding='utf-8') as f:
                    imported_data = json.load(f)
            
            elif ext in ['.yaml', '.yml']:
                import yaml
                with open(file_path, 'r', encoding='utf-8') as f:
                    imported_data = yaml.safe_load(f)
            
            elif ext == '.ini':
                config_parser = configparser.ConfigParser()
                config_parser.optionxform = str
                config_parser.read(file_path, encoding='utf-8')
                
                imported_data = {}
                for section in config_parser.sections():
                    imported_data[section] = {}
                    for key in config_parser.options(section):
                        imported_data[section][key] = config_parser.get(section, key)
            
            else:
                raise ValueError(f"Formato de arquivo não suportado: {ext}")
            
            if merge:
                # Mescla com configurações existentes
                for section, options in imported_data.items():
                    if section not in self.config_data:
                        self.config_data[section] = {}
                    for key, value in options.items():
                        self.config_data[section][key] = value
            else:
                # Substitui completamente
                self.config_data = imported_data
            
            self._validate_config()
            self.save()
            
            print(f"Configurações importadas de {file_path}")
            return True
            
        except Exception as e:
            print(f"Erro ao importar configurações: {e}")
            return False
    
    def reset_to_defaults(self, section=None):
        """Redefine para configurações padrão"""
        if section:
            if section in self.default_config:
                self.config_data[section] = self.default_config[section].copy()
            else:
                print(f"Seção não encontrada: {section}")
                return False
        else:
            self.config_data = self.default_config.copy()
        
        self.save()
        print("Configurações redefinidas para padrão")
        return True
    
    def _on_encryption_changed(self, old_value, new_value):
        """Callback quando encryption_enabled muda"""
        print(f"Configuração de criptografia alterada: {old_value} -> {new_value}")
    
    def _on_2fa_changed(self, old_value, new_value):
        """Callback quando enable_2fa muda"""
        print(f"Configuração 2FA alterada: {old_value} -> {new_value}")
    
    def _on_ssl_verify_changed(self, old_value, new_value):
        """Callback quando ssl_verify muda"""
        print(f"Verificação SSL alterada: {old_value} -> {new_value}")
    
    def _on_log_level_changed(self, old_value, new_value):
        """Callback quando log_level muda"""
        print(f"Nível de log alterado: {old_value} -> {new_value}")
    
    def _on_updates_changed(self, old_value, new_value):
        """Callback quando automatic_updates muda"""
        print(f"Atualizações automáticas alteradas: {old_value} -> {new_value}")
    
    def _on_notifications_changed(self, old_value, new_value):
        """Callback quando notifications_enabled muda"""
        print(f"Notificações alteradas: {old_value} -> {new_value}")

# ============================================================================
# SISTEMA DE GERENCIAMENTO DE MÓDULOS (1.500+ linhas)
# ============================================================================

class LeonardoModuleManager:
    """Gerenciador avançado de módulos OSINT"""
    
    class ModuleType(enum.Enum):
        """Tipos de módulos suportados"""
        SOCIAL_MEDIA = "social_media"
        DOMAIN_INTEL = "domain_intelligence"
        EMAIL_INTEL = "email_intelligence"
        IMAGE_INTEL = "image_intelligence"
        PHONE_INTEL = "phone_intelligence"
        GEOLOCATION = "geolocation"
        BLOCKCHAIN = "blockchain"
        VULNERABILITY = "vulnerability"
        NETWORK_SCAN = "network_scan"
        FORENSICS = "forensics"
        MALWARE_ANALYSIS = "malware_analysis"
        THREAT_INTEL = "threat_intelligence"
        OSINT_FRAMEWORK = "osint_framework"
        AUTOMATED_RECON = "automated_recon"
        REPORTING = "reporting"
        VISUALIZATION = "visualization"
        AUTOMATION = "automation"
        INTEGRATION = "integration"
        AI_ANALYSIS = "ai_analysis"
        DARKWEB = "darkweb"
        CUSTOM = "custom"
    
    class ModuleStatus(enum.Enum):
        """Status dos módulos"""
        NOT_LOADED = "not_loaded"
        LOADING = "loading"
        LOADED = "loaded"
        INITIALIZING = "initializing"
        READY = "ready"
        RUNNING = "running"
        PAUSED = "paused"
        STOPPED = "stopped"
        ERROR = "error"
        DISABLED = "disabled"
        UPDATING = "updating"
        DEPRECATED = "deprecated"
    
    class ModulePermission(enum.Flag):
        """Permissões dos módulos"""
        NONE = 0
        READ = 1
        WRITE = 2
        EXECUTE = 4
        NETWORK = 8
        FILESYSTEM = 16
        DATABASE = 32
        SYSTEM = 64
        ALL = READ | WRITE | EXECUTE | NETWORK | FILESYSTEM | DATABASE | SYSTEM
    
    @dataclasses.dataclass
    class ModuleInfo:
        """Informações sobre um módulo"""
        name: str
        type: 'LeonardoModuleManager.ModuleType'
        version: str
        author: str
        description: str
        dependencies: List[str]
        required_apis: List[str]
        permissions: 'LeonardoModuleManager.ModulePermission'
        status: 'LeonardoModuleManager.ModuleStatus'
        enabled: bool
        path: str
        config: Dict[str, Any]
        metadata: Dict[str, Any]
        
        def to_dict(self):
            """Converte para dicionário"""
            return {
                'name': self.name,
                'type': self.type.value,
                'version': self.version,
                'author': self.author,
                'description': self.description,
                'dependencies': self.dependencies,
                'required_apis': self.required_apis,
                'permissions': self.permissions.value,
                'status': self.status.value,
                'enabled': self.enabled,
                'path': self.path,
                'config': self.config,
                'metadata': self.metadata
            }
        
        @classmethod
        def from_dict(cls, data):
            """Cria a partir de dicionário"""
            return cls(
                name=data['name'],
                type=LeonardoModuleManager.ModuleType(data['type']),
                version=data['version'],
                author=data['author'],
                description=data['description'],
                dependencies=data['dependencies'],
                required_apis=data['required_apis'],
                permissions=LeonardoModuleManager.ModulePermission(data['permissions']),
                status=LeonardoModuleManager.ModuleStatus(data['status']),
                enabled=data['enabled'],
                path=data['path'],
                config=data['config'],
                metadata=data['metadata']
            )
    
    class BaseModule(ABC):
        """Classe base para todos os módulos"""
        
        def __init__(self, module_info: 'LeonardoModuleManager.ModuleInfo'):
            self.info = module_info
            self.logger = logging.getLogger(f"LeonardoOSINT.Modules.{module_info.name}")
            self.config = LeonardoConfig()
            self.results = []
            self.errors = []
            self.warnings = []
            self.start_time = None
            self.end_time = None
            
        @abstractmethod
        def initialize(self) -> bool:
            """Inicializa o módulo"""
            pass
        
        @abstractmethod
        def execute(self, target: Any, options: Dict[str, Any] = None) -> List[Dict[str, Any]]:
            """Executa o módulo com o alvo especificado"""
            pass
        
        @abstractmethod
        def cleanup(self) -> bool:
            """Limpa recursos do módulo"""
            pass
        
        def validate(self) -> List[str]:
            """Valida se o módulo pode ser executado"""
            errors = []
            
            # Verifica dependências
            for dep in self.info.dependencies:
                try:
                    importlib.import_module(dep)
                except ImportError:
                    errors.append(f"Dependência não encontrada: {dep}")
            
            # Verifica APIs necessárias
            for api in self.info.required_apis:
                api_key = self.config.get('API_Keys', f'{api}_api_key', '')
                if not api_key:
                    errors.append(f"API key não configurada: {api}")
            
            return errors
        
        def get_status(self) -> Dict[str, Any]:
            """Retorna status do módulo"""
            return {
                'name': self.info.name,
                'status': self.info.status.value,
                'enabled': self.info.enabled,
                'errors': len(self.errors),
                'warnings': len(self.warnings),
                'results': len(self.results),
                'running_time': self._get_running_time(),
                'memory_usage': self._get_memory_usage()
            }
        
        def _get_running_time(self):
            """Calcula tempo de execução"""
            if self.start_time and self.end_time:
                return self.end_time - self.start_time
            elif self.start_time:
                return time.time() - self.start_time
            return 0
        
        def _get_memory_usage(self):
            """Obtém uso de memória"""
            try:
                import psutil
                process = psutil.Process()
                return process.memory_info().rss
            except:
                return 0
        
        def save_results(self, filename: str = None):
            """Salva resultados em arquivo"""
            if not filename:
                timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
                filename = f"results_{self.info.name}_{timestamp}.json"
            
            data = {
                'module': self.info.to_dict(),
                'results': self.results,
                'errors': self.errors,
                'warnings': self.warnings,
                'execution_time': self._get_running_time(),
                'generated_at': datetime.datetime.now().isoformat()
            }
            
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            
            self.logger.info(f"Resultados salvos em {filename}")
            return filename
        
        def export_results(self, format: str = 'json', filename: str = None):
            """Exporta resultados em diferentes formatos"""
            if format == 'json':
                return self.save_results(filename)
            elif format == 'csv':
                return self._export_csv(filename)
            elif format == 'html':
                return self._export_html(filename)
            elif format == 'pdf':
                return self._export_pdf(filename)
            else:
                raise ValueError(f"Formato não suportado: {format}")
        
        def _export_csv(self, filename: str = None):
            """Exporta resultados como CSV"""
            if not filename:
                timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
                filename = f"results_{self.info.name}_{timestamp}.csv"
            
            # Implementação simplificada
            with open(filename, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(['Result', 'Type', 'Confidence', 'Timestamp'])
                for result in self.results:
                    writer.writerow([
                        str(result.get('data', ''))[:100],
                        result.get('type', 'unknown'),
                        result.get('confidence', 0),
                        result.get('timestamp', '')
                    ])
            
            self.logger.info(f"Resultados exportados como CSV: {filename}")
            return filename
        
        def _export_html(self, filename: str = None):
            """Exporta resultados como HTML"""
            if not filename:
                timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
                filename = f"results_{self.info.name}_{timestamp}.html"
            
            html_template = """
            <!DOCTYPE html>
            <html>
            <head>
                <title>Leonardo OSINT Report - {module_name}</title>
                <style>
                    body {{ font-family: Arial, sans-serif; margin: 20px; }}
                    .header {{ background-color: #2c3e50; color: white; padding: 20px; border-radius: 5px; }}
                    .result {{ border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }}
                    .error {{ border-color: #e74c3c; background-color: #ffe6e6; }}
                    .warning {{ border-color: #f39c12; background-color: #fff3cd; }}
                    .success {{ border-color: #27ae60; background-color: #e6ffe6; }}
                </style>
            </head>
            <body>
                <div class="header">
                    <h1>Leonardo Pereira OSINT Suite</h1>
                    <h2>Relatório do Módulo: {module_name}</h2>
                    <p>Gerado em: {timestamp}</p>
                </div>
                
                <h3>Resultados ({result_count})</h3>
                {results_html}
                
                <h3>Erros ({error_count})</h3>
                {errors_html}
                
                <h3>Avisos ({warning_count})</h3>
                {warnings_html}
                
                <footer>
                    <p>Report gerado automaticamente pela Leonardo Pereira OSINT Suite</p>
                </footer>
            </body>
            </html>
            """
            
            # Gera HTML para resultados
            results_html = ""
            for result in self.results:
                result_class = "success"
                if result.get('confidence', 0) < 0.5:
                    result_class = "warning"
                
                results_html += f"""
                <div class="result {result_class}">
                    <strong>{result.get('type', 'Unknown')}</strong>
                    <p>{result.get('data', '')}</p>
                    <small>Confiança: {result.get('confidence', 0)} | Fonte: {result.get('source', 'Unknown')}</small>
                </div>
                """
            
            # Gera HTML para erros
            errors_html = ""
            for error in self.errors:
                errors_html += f"""
                <div class="result error">
                    <strong>Erro</strong>
                    <p>{error}</p>
                </div>
                """
            
            # Gera HTML para avisos
            warnings_html = ""
            for warning in self.warnings:
                warnings_html += f"""
                <div class="result warning">
                    <strong>Aviso</strong>
                    <p>{warning}</p>
                </div>
                """
            
            html_content = html_template.format(
                module_name=self.info.name,
                timestamp=datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                result_count=len(self.results),
                error_count=len(self.errors),
                warning_count=len(self.warnings),
                results_html=results_html,
                errors_html=errors_html,
                warnings_html=warnings_html
            )
            
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            self.logger.info(f"Resultados exportados como HTML: {filename}")
            return filename
        
        def _export_pdf(self, filename: str = None):
            """Exporta resultados como PDF"""
            # Requer bibliotecas adicionais
            try:
                from reportlab.lib.pagesizes import letter
                from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
                from reportlab.lib.styles import getSampleStyleSheet
                
                if not filename:
                    timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
                    filename = f"results_{self.info.name}_{timestamp}.pdf"
                
                doc = SimpleDocTemplate(filename, pagesize=letter)
                styles = getSampleStyleSheet()
                story = []
                
                # Adiciona conteúdo
                title = Paragraph(f"Leonardo OSINT Report - {self.info.name}", styles['Title'])
                story.append(title)
                story.append(Spacer(1, 12))
                
                # Adiciona resultados
                for result in self.results:
                    result_text = Paragraph(f"<b>{result.get('type', 'Unknown')}</b>: {result.get('data', '')}", styles['Normal'])
                    story.append(result_text)
                    story.append(Spacer(1, 6))
                
                doc.build(story)
                
                self.logger.info(f"Resultados exportados como PDF: {filename}")
                return filename
                
            except ImportError:
                self.logger.error("Biblioteca reportlab não instalada para exportação PDF")
                return None
    
    def __init__(self, config: LeonardoConfig = None):
        """Inicializa o gerenciador de módulos"""
        self.config = config or LeonardoConfig()
        self.logger = logging.getLogger("LeonardoOSINT.ModuleManager")
        self.modules = {}
        self.module_instances = {}
        self.loaded_modules = {}
        self.module_directories = [
            'modules',
            'custom_modules',
            os.path.expanduser('~/.leonardo/modules'),
            '/usr/share/leonardo/modules'
        ]
        
        # Cria diretórios necessários
        for directory in self.module_directories:
            os.makedirs(directory, exist_ok=True)
        
        # Inicializa banco de dados de módulos
        self._init_module_database()
        
        # Carrega módulos
        self.load_all_modules()
    
    def _init_module_database(self):
        """Inicializa banco de dados para módulos"""
        self.db_path = self.config.get('Database', 'db_path', LeonardoConstants.Defaults.DB_PATH)
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Tabela de módulos
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS modules (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT UNIQUE,
            type TEXT,
            version TEXT,
            author TEXT,
            description TEXT,
            dependencies TEXT,
            required_apis TEXT,
            permissions INTEGER,
            status TEXT,
            enabled INTEGER,
            path TEXT,
            config TEXT,
            metadata TEXT,
            last_loaded DATETIME,
            last_executed DATETIME,
            execution_count INTEGER DEFAULT 0,
            success_count INTEGER DEFAULT 0,
            error_count INTEGER DEFAULT 0,
            total_execution_time REAL DEFAULT 0,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
        ''')
        
        # Tabela de execuções
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS module_executions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            module_name TEXT,
            target TEXT,
            options TEXT,
            results_count INTEGER,
            errors_count INTEGER,
            warnings_count INTEGER,
            execution_time REAL,
            status TEXT,
            output_file TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (module_name) REFERENCES modules (name)
        )
        ''')
        
        # Tabela de resultados
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS module_results (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            execution_id INTEGER,
            result_type TEXT,
            result_data TEXT,
            confidence REAL,
            source TEXT,
            metadata TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (execution_id) REFERENCES module_executions (id)
        )
        ''')
        
        conn.commit()
        conn.close()
    
    def load_all_modules(self):
        """Carrega todos os módulos disponíveis"""
        self.logger.info("Carregando todos os módulos...")
        
        for directory in self.module_directories:
            if os.path.exists(directory):
                self._load_modules_from_directory(directory)
        
        self.logger.info(f"Total de módulos carregados: {len(self.modules)}")
        
        # Atualiza status no banco de dados
        self._update_module_database()
    
    def _load_modules_from_directory(self, directory):
        """Carrega módulos de um diretório"""
        for item in os.listdir(directory):
            item_path = os.path.join(directory, item)
            
            # Verifica se é um diretório de módulo
            if os.path.isdir(item_path):
                module_file = os.path.join(item_path, 'module.py')
                config_file = os.path.join(item_path, 'config.json')
                
                if os.path.exists(module_file) and os.path.exists(config_file):
                    try:
                        module_info = self._load_module_info(item_path, config_file)
                        if module_info:
                            self.modules[module_info.name] = module_info
                            self.logger.info(f"Módulo carregado: {module_info.name}")
                    except Exception as e:
                        self.logger.error(f"Erro ao carregar módulo {item}: {e}")
            
            # Verifica se é um arquivo Python de módulo único
            elif item.endswith('.py') and item != '__init__.py':
                try:
                    module_info = self._load_single_file_module(item_path)
                    if module_info:
                        self.modules[module_info.name] = module_info
                        self.logger.info(f"Módulo carregado (arquivo único): {module_info.name}")
                except Exception as e:
                    self.logger.error(f"Erro ao carregar módulo {item}: {e}")
    
    def _load_module_info(self, module_path, config_file):
        """Carrega informações do módulo do arquivo de configuração"""
        try:
            with open(config_file, 'r', encoding='utf-8') as f:
                config_data = json.load(f)
            
            # Valida configuração mínima
            required_fields = ['name', 'type', 'version', 'author', 'description']
            for field in required_fields:
                if field not in config_data:
                    raise ValueError(f"Campo obrigatório faltando: {field}")
            
            module_info = self.ModuleInfo(
                name=config_data['name'],
                type=self.ModuleType(config_data['type']),
                version=config_data['version'],
                author=config_data['author'],
                description=config_data['description'],
                dependencies=config_data.get('dependencies', []),
                required_apis=config_data.get('required_apis', []),
                permissions=self.ModulePermission(config_data.get('permissions', 0)),
                status=self.ModuleStatus.NOT_LOADED,
                enabled=config_data.get('enabled', True),
                path=module_path,
                config=config_data.get('config', {}),
                metadata=config_data.get('metadata', {})
            )
            
            return module_info
            
        except Exception as e:
            self.logger.error(f"Erro ao carregar informações do módulo {config_file}: {e}")
            return None
    
    def _load_single_file_module(self, file_path):
        """Carrega módulo de um único arquivo Python"""
        try:
            # Extrai informações do arquivo
            module_name = os.path.splitext(os.path.basename(file_path))[0]
            
            # Lê o arquivo para extrair metadados
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Extrai informações usando regex
            version_match = re.search(r'__version__\s*=\s*[\'"]([^\'"]+)[\'"]', content)
            author_match = re.search(r'__author__\s*=\s*[\'"]([^\'"]+)[\'"]', content)
            description_match = re.search(r'__description__\s*=\s*[\'"]([^\'"]+)[\'"]', content)
            
            module_info = self.ModuleInfo(
                name=module_name,
                type=self.ModuleType.CUSTOM,
                version=version_match.group(1) if version_match else '1.0.0',
                author=author_match.group(1) if author_match else 'Unknown',
                description=description_match.group(1) if description_match else 'Single file module',
                dependencies=[],
                required_apis=[],
                permissions=self.ModulePermission.READ | self.ModulePermission.EXECUTE,
                status=self.ModuleStatus.NOT_LOADED,
                enabled=True,
                path=file_path,
                config={},
                metadata={'single_file': True}
            )
            
            return module_info
            
        except Exception as e:
            self.logger.error(f"Erro ao carregar módulo de arquivo único {file_path}: {e}")
            return None
    
    def _update_module_database(self):
        """Atualiza banco de dados com informações dos módulos"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        for module_name, module_info in self.modules.items():
            # Converte para JSON
            dependencies_json = json.dumps(module_info.dependencies)
            required_apis_json = json.dumps(module_info.required_apis)
            config_json = json.dumps(module_info.config)
            metadata_json = json.dumps(module_info.metadata)
            
            # Verifica se o módulo já existe
            cursor.execute("SELECT id FROM modules WHERE name = ?", (module_name,))
            existing = cursor.fetchone()
            
            if existing:
                # Atualiza módulo existente
                cursor.execute('''
                UPDATE modules SET
                    type = ?,
                    version = ?,
                    author = ?,
                    description = ?,
                    dependencies = ?,
                    required_apis = ?,
                    permissions = ?,
                    status = ?,
                    enabled = ?,
                    path = ?,
                    config = ?,
                    metadata = ?,
                    updated_at = CURRENT_TIMESTAMP
                WHERE name = ?
                ''', (
                    module_info.type.value,
                    module_info.version,
                    module_info.author,
                    module_info.description,
                    dependencies_json,
                    required_apis_json,
                    module_info.permissions.value,
                    module_info.status.value,
                    1 if module_info.enabled else 0,
                    module_info.path,
                    config_json,
                    metadata_json,
                    module_name
                ))
            else:
                # Insere novo módulo
                cursor.execute('''
                INSERT INTO modules (
                    name, type, version, author, description, dependencies,
                    required_apis, permissions, status, enabled, path,
                    config, metadata
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    module_name,
                    module_info.type.value,
                    module_info.version,
                    module_info.author,
                    module_info.description,
                    dependencies_json,
                    required_apis_json,
                    module_info.permissions.value,
                    module_info.status.value,
                    1 if module_info.enabled else 0,
                    module_info.path,
                    config_json,
                    metadata_json
                ))
        
        conn.commit()
        conn.close()
    
    def get_module(self, module_name):
        """Obtém informações de um módulo"""
        if module_name in self.modules:
            return self.modules[module_name]
        return None
    
    def get_all_modules(self):
        """Obtém todos os módulos"""
        return list(self.modules.values())
    
    def get_modules_by_type(self, module_type):
        """Obtém módulos por tipo"""
        return [m for m in self.modules.values() if m.type == module_type]
    
    def get_enabled_modules(self):
        """Obtém módulos habilitados"""
        return [m for m in self.modules.values() if m.enabled]
    
    def get_disabled_modules(self):
        """Obtém módulos desabilitados"""
        return [m for m in self.modules.values() if not m.enabled]
    
    def enable_module(self, module_name):
        """Habilita um módulo"""
        if module_name in self.modules:
            self.modules[module_name].enabled = True
            
            # Atualiza banco de dados
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("UPDATE modules SET enabled = 1 WHERE name = ?", (module_name,))
            conn.commit()
            conn.close()
            
            self.logger.info(f"Módulo habilitado: {module_name}")
            return True
        
        self.logger.warning(f"Módulo não encontrado: {module_name}")
        return False
    
    def disable_module(self, module_name):
        """Desabilita um módulo"""
        if module_name in self.modules:
            self.modules[module_name].enabled = False
            
            # Atualiza banco de dados
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("UPDATE modules SET enabled = 0 WHERE name = ?", (module_name,))
            conn.commit()
            conn.close()
            
            self.logger.info(f"Módulo desabilitado: {module_name}")
            return True
        
        self.logger.warning(f"Módulo não encontrado: {module_name}")
        return False
    
    def load_module_instance(self, module_name):
        """Carrega uma instância de um módulo"""
        if module_name in self.module_instances:
            return self.module_instances[module_name]
        
        if module_name not in self.modules:
            self.logger.error(f"Módulo não encontrado: {module_name}")
            return None
        
        module_info = self.modules[module_name]
        
        try:
            # Adiciona diretório do módulo ao path
            module_dir = os.path.dirname(module_info.path)
            if module_dir not in sys.path:
                sys.path.insert(0, module_dir)
            
            # Carrega o módulo
            if module_info.metadata.get('single_file', False):
                # Módulo de arquivo único
                spec = importlib.util.spec_from_file_location(module_name, module_info.path)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
            else:
                # Módulo em diretório
                module = importlib.import_module('module', module_dir)
            
            # Procura a classe do módulo
            module_class = None
            for attr_name in dir(module):
                attr = getattr(module, attr_name)
                if (isinstance(attr, type) and 
                    issubclass(attr, self.BaseModule) and 
                    attr != self.BaseModule):
                    module_class = attr
                    break
            
            if not module_class:
                raise ValueError(f"Classe de módulo não encontrada em {module_name}")
            
            # Cria instância
            module_instance = module_class(module_info)
            
            # Atualiza status
            module_info.status = self.ModuleStatus.LOADED
            
            # Armazena instância
            self.module_instances[module_name] = module_instance
            self.loaded_modules[module_name] = module_info
            
            self.logger.info(f"Instância do módulo carregada: {module_name}")
            return module_instance
            
        except Exception as e:
            self.logger.error(f"Erro ao carregar instância do módulo {module_name}: {e}")
            module_info.status = self.ModuleStatus.ERROR
            return None
    
    def execute_module(self, module_name, target, options=None):
        """Executa um módulo"""
        if options is None:
            options = {}
        
        # Carrega instância se necessário
        module_instance = self.load_module_instance(module_name)
        if not module_instance:
            return None
        
        module_info = self.modules[module_name]
        
        try:
            # Atualiza status
            module_info.status = self.ModuleStatus.RUNNING
            
            # Valida módulo
            validation_errors = module_instance.validate()
            if validation_errors:
                module_info.status = self.ModuleStatus.ERROR
                self.logger.error(f"Erros de validação em {module_name}: {validation_errors}")
                return {
                    'success': False,
                    'errors': validation_errors,
                    'results': []
                }
            
            # Inicializa módulo
            if not module_instance.initialize():
                module_info.status = self.ModuleStatus.ERROR
                self.logger.error(f"Falha ao inicializar módulo {module_name}")
                return {
                    'success': False,
                    'errors': ['Falha na inicialização'],
                    'results': []
                }
            
            # Executa módulo
            module_instance.start_time = time.time()
            results = module_instance.execute(target, options)
            module_instance.end_time = time.time()
            
            # Atualiza status
            module_info.status = self.ModuleStatus.READY
            
            # Limpa módulo
            module_instance.cleanup()
            
            # Atualiza estatísticas no banco de dados
            self._update_module_stats(module_name, True, module_instance._get_running_time())
            
            # Salva execução no banco de dados
            execution_id = self._save_execution(
                module_name, target, options, 
                len(results), len(module_instance.errors), 
                len(module_instance.warnings),
                module_instance._get_running_time(),
                'success'
            )
            
            # Salva resultados no banco de dados
            if execution_id and results:
                self._save_results(execution_id, results)
            
            self.logger.info(f"Módulo executado com sucesso: {module_name}")
            
            return {
                'success': True,
                'execution_id': execution_id,
                'results': results,
                'errors': module_instance.errors,
                'warnings': module_instance.warnings,
                'execution_time': module_instance._get_running_time(),
                'module_info': module_info.to_dict()
            }
            
        except Exception as e:
            module_info.status = self.ModuleStatus.ERROR
            self.logger.error(f"Erro ao executar módulo {module_name}: {e}")
            
            # Atualiza estatísticas no banco de dados
            self._update_module_stats(module_name, False, 0)
            
            # Salva execução falha no banco de dados
            self._save_execution(
                module_name, target, options, 
                0, 1, 0, 0, 'error'
            )
            
            return {
                'success': False,
                'errors': [str(e)],
                'results': []
            }
    
    def execute_multiple_modules(self, module_names, target, options=None):
        """Executa múltiplos módulos em paralelo"""
        if options is None:
            options = {}
        
        results = {}
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            future_to_module = {
                executor.submit(self.execute_module, module_name, target, options): module_name
                for module_name in module_names
                if module_name in self.modules and self.modules[module_name].enabled
            }
            
            for future in concurrent.futures.as_completed(future_to_module):
                module_name = future_to_module[future]
                try:
                    result = future.result()
                    results[module_name] = result
                except Exception as e:
                    results[module_name] = {
                        'success': False,
                        'errors': [str(e)],
                        'results': []
                    }
        
        return results
    
    def execute_all_modules(self, target, options=None):
        """Executa todos os módulos habilitados"""
        enabled_modules = [m.name for m in self.get_enabled_modules()]
        return self.execute_multiple_modules(enabled_modules, target, options)
    
    def _update_module_stats(self, module_name, success, execution_time):
        """Atualiza estatísticas do módulo no banco de dados"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        UPDATE modules SET
            execution_count = execution_count + 1,
            success_count = success_count + ?,
            error_count = error_count + ?,
            total_execution_time = total_execution_time + ?,
            last_executed = CURRENT_TIMESTAMP,
            updated_at = CURRENT_TIMESTAMP
        WHERE name = ?
        ''', (1 if success else 0, 0 if success else 1, execution_time, module_name))
        
        conn.commit()
        conn.close()
    
    def _save_execution(self, module_name, target, options, results_count, 
                       errors_count, warnings_count, execution_time, status):
        """Salva execução no banco de dados"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        options_json = json.dumps(options)
        
        cursor.execute('''
        INSERT INTO module_executions (
            module_name, target, options, results_count, errors_count,
            warnings_count, execution_time, status
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            module_name, str(target), options_json, results_count,
            errors_count, warnings_count, execution_time, status
        ))
        
        execution_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        return execution_id
    
    def _save_results(self, execution_id, results):
        """Salva resultados no banco de dados"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        for result in results:
            result_data = json.dumps(result.get('data', {}))
            metadata = json.dumps(result.get('metadata', {}))
            
            cursor.execute('''
            INSERT INTO module_results (
                execution_id, result_type, result_data, confidence,
                source, metadata
            ) VALUES (?, ?, ?, ?, ?, ?)
            ''', (
                execution_id,
                result.get('type', 'unknown'),
                result_data,
                result.get('confidence', 0.0),
                result.get('source', 'unknown'),
                metadata
            ))
        
        conn.commit()
        conn.close()
    
    def get_module_stats(self, module_name=None):
        """Obtém estatísticas dos módulos"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        if module_name:
            cursor.execute('''
            SELECT 
                name,
                execution_count,
                success_count,
                error_count,
                total_execution_time,
                last_executed
            FROM modules WHERE name = ?
            ''', (module_name,))
        else:
            cursor.execute('''
            SELECT 
                name,
                execution_count,
                success_count,
                error_count,
                total_execution_time,
                last_executed
            FROM modules
            ''')
        
        stats = {}
        for row in cursor.fetchall():
            name, exec_count, success_count, error_count, total_time, last_executed = row
            avg_time = total_time / exec_count if exec_count > 0 else 0
            success_rate = (success_count / exec_count * 100) if exec_count > 0 else 0
            
            stats[name] = {
                'execution_count': exec_count,
                'success_count': success_count,
                'error_count': error_count,
                'total_execution_time': total_time,
                'average_execution_time': avg_time,
                'success_rate': success_rate,
                'last_executed': last_executed
            }
        
        conn.close()
        return stats
    
    def get_execution_history(self, module_name=None, limit=100):
        """Obtém histórico de execuções"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        if module_name:
            cursor.execute('''
            SELECT 
                id, module_name, target, results_count, errors_count,
                warnings_count, execution_time, status, created_at
            FROM module_executions 
            WHERE module_name = ?
            ORDER BY created_at DESC
            LIMIT ?
            ''', (module_name, limit))
        else:
            cursor.execute('''
            SELECT 
                id, module_name, target, results_count, errors_count,
                warnings_count, execution_time, status, created_at
            FROM module_executions 
            ORDER BY created_at DESC
            LIMIT ?
            ''', (limit,))
        
        history = []
        for row in cursor.fetchall():
            exec_id, mod_name, target, results_count, errors_count, warnings_count, exec_time, status, created_at = row
            history.append({
                'id': exec_id,
                'module_name': mod_name,
                'target': target,
                'results_count': results_count,
                'errors_count': errors_count,
                'warnings_count': warnings_count,
                'execution_time': exec_time,
                'status': status,
                'created_at': created_at
            })
        
        conn.close()
        return history
    
    def get_execution_results(self, execution_id):
        """Obtém resultados de uma execução específica"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Obtém informações da execução
        cursor.execute('''
        SELECT 
            module_name, target, options, results_count, errors_count,
            warnings_count, execution_time, status, created_at
        FROM module_executions 
        WHERE id = ?
        ''', (execution_id,))
        
        exec_info = cursor.fetchone()
        if not exec_info:
            conn.close()
            return None
        
        mod_name, target, options_json, results_count, errors_count, warnings_count, exec_time, status, created_at = exec_info
        
        # Obtém resultados
        cursor.execute('''
        SELECT 
            result_type, result_data, confidence, source, metadata, created_at
        FROM module_results 
        WHERE execution_id = ?
        ORDER BY created_at
        ''', (execution_id,))
        
        results = []
        for row in cursor.fetchall():
            result_type, result_data, confidence, source, metadata, result_created_at = row
            results.append({
                'type': result_type,
                'data': json.loads(result_data) if result_data else {},
                'confidence': confidence,
                'source': source,
                'metadata': json.loads(metadata) if metadata else {},
                'created_at': result_created_at
            })
        
        conn.close()
        
        return {
            'execution_id': execution_id,
            'module_name': mod_name,
            'target': target,
            'options': json.loads(options_json) if options_json else {},
            'results_count': results_count,
            'errors_count': errors_count,
            'warnings_count': warnings_count,
            'execution_time': exec_time,
            'status': status,
            'created_at': created_at,
            'results': results
        }
    
    def install_module(self, source, install_dir='custom_modules'):
        """Instala um novo módulo"""
        try:
            # Cria diretório de instalação
            os.makedirs(install_dir, exist_ok=True)
            
            if source.startswith('http://') or source.startswith('https://'):
                # Download de URL
                module_zip = self._download_module(source, install_dir)
                if not module_zip:
                    return False
                
                # Extrai arquivo
                extracted_dir = self._extract_module(module_zip, install_dir)
                if not extracted_dir:
                    return False
                
                module_path = extracted_dir
                
            elif os.path.isdir(source):
                # Diretório local
                module_path = source
                
            elif os.path.isfile(source) and source.endswith('.zip'):
                # Arquivo ZIP local
                extracted_dir = self._extract_module(source, install_dir)
                if not extracted_dir:
                    return False
                
                module_path = extracted_dir
                
            else:
                self.logger.error(f"Fonte de módulo não suportada: {source}")
                return False
            
            # Carrega módulo
            config_file = os.path.join(module_path, 'config.json')
            if not os.path.exists(config_file):
                self.logger.error(f"Arquivo config.json não encontrado em {module_path}")
                return False
            
            module_info = self._load_module_info(module_path, config_file)
            if not module_info:
                return False
            
            # Verifica se módulo já existe
            if module_info.name in self.modules:
                self.logger.warning(f"Módulo {module_info.name} já existe. Substituindo...")
            
            # Adiciona módulo
            self.modules[module_info.name] = module_info
            
            # Atualiza banco de dados
            self._update_module_database()
            
            self.logger.info(f"Módulo instalado com sucesso: {module_info.name}")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro ao instalar módulo: {e}")
            return False
    
    def _download_module(self, url, download_dir):
        """Faz download de um módulo"""
        try:
            import requests
            
            self.logger.info(f"Baixando módulo de {url}")
            
            response = requests.get(url, timeout=30)
            response.raise_for_status()
            
            # Determina nome do arquivo
            filename = os.path.join(download_dir, 'module.zip')
            
            with open(filename, 'wb') as f:
                f.write(response.content)
            
            self.logger.info(f"Módulo baixado: {filename}")
            return filename
            
        except Exception as e:
            self.logger.error(f"Erro ao baixar módulo: {e}")
            return None
    
    def _extract_module(self, zip_file, extract_dir):
        """Extrai um módulo compactado"""
        try:
            import zipfile
            
            self.logger.info(f"Extraindo módulo: {zip_file}")
            
            with zipfile.ZipFile(zip_file, 'r') as zip_ref:
                # Determina diretório raiz
                root_dir = None
                for name in zip_ref.namelist():
                    if name.endswith('/config.json'):
                        root_dir = name.split('/')[0]
                        break
                
                if not root_dir:
                    # Extrai tudo
                    zip_ref.extractall(extract_dir)
                    extracted_path = os.path.join(extract_dir, os.path.splitext(os.path.basename(zip_file))[0])
                else:
                    # Extrai apenas diretório raiz
                    for member in zip_ref.namelist():
                        if member.startswith(root_dir + '/'):
                            zip_ref.extract(member, extract_dir)
                    
                    extracted_path = os.path.join(extract_dir, root_dir)
            
            self.logger.info(f"Módulo extraído para: {extracted_path}")
            
            # Remove arquivo ZIP
            os.remove(zip_file)
            
            return extracted_path
            
        except Exception as e:
            self.logger.error(f"Erro ao extrair módulo: {e}")
            return None
    
    def uninstall_module(self, module_name):
        """Desinstala um módulo"""
        if module_name not in self.modules:
            self.logger.warning(f"Módulo não encontrado: {module_name}")
            return False
        
        module_info = self.modules[module_name]
        
        try:
            # Remove instância carregada
            if module_name in self.module_instances:
                del self.module_instances[module_name]
            
            if module_name in self.loaded_modules:
                del self.loaded_modules[module_name]
            
            # Remove do dicionário de módulos
            del self.modules[module_name]
            
            # Remove do banco de dados
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("DELETE FROM modules WHERE name = ?", (module_name,))
            conn.commit()
            conn.close()
            
            # Opcional: Remove arquivos do módulo
            # Nota: Isso é perigoso, então comente se quiser manter os arquivos
            # if os.path.exists(module_info.path):
            #     import shutil
            #     shutil.rmtree(module_info.path)
            #     self.logger.info(f"Arquivos do módulo removidos: {module_info.path}")
            
            self.logger.info(f"Módulo desinstalado: {module_name}")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro ao desinstalar módulo: {e}")
            return False
    
    def update_module(self, module_name, source=None):
        """Atualiza um módulo"""
        if module_name not in self.modules:
            self.logger.warning(f"Módulo não encontrado: {module_name}")
            return False
        
        module_info = self.modules[module_name]
        
        try:
            self.logger.info(f"Atualizando módulo: {module_name}")
            
            # Backup do módulo atual
            backup_dir = f"backups/modules/{module_name}_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}"
            os.makedirs(backup_dir, exist_ok=True)
            
            import shutil
            if os.path.exists(module_info.path):
                if os.path.isfile(module_info.path):
                    shutil.copy2(module_info.path, backup_dir)
                else:
                    shutil.copytree(module_info.path, os.path.join(backup_dir, os.path.basename(module_info.path)))
            
            self.logger.info(f"Backup criado em: {backup_dir}")
            
            # Se source não for especificada, tenta obter do metadata
            if not source:
                source = module_info.metadata.get('update_url')
                if not source:
                    self.logger.error("URL de atualização não especificada")
                    return False
            
            # Instala nova versão
            if self.install_module(source, os.path.dirname(module_info.path)):
                self.logger.info(f"Módulo atualizado com sucesso: {module_name}")
                return True
            else:
                self.logger.error("Falha ao instalar nova versão. Restaurando backup...")
                
                # Restaura backup
                if os.path.exists(backup_dir):
                    if os.path.isfile(module_info.path):
                        backup_file = os.path.join(backup_dir, os.path.basename(module_info.path))
                        if os.path.exists(backup_file):
                            shutil.copy2(backup_file, module_info.path)
                    else:
                        backup_path = os.path.join(backup_dir, os.path.basename(module_info.path))
                        if os.path.exists(backup_path):
                            shutil.rmtree(module_info.path, ignore_errors=True)
                            shutil.copytree(backup_path, module_info.path)
                
                # Recarrega módulo
                config_file = os.path.join(module_info.path, 'config.json')
                if os.path.exists(config_file):
                    self.modules[module_name] = self._load_module_info(module_info.path, config_file)
                    self._update_module_database()
                
                self.logger.info("Backup restaurado")
                return False
            
        except Exception as e:
            self.logger.error(f"Erro ao atualizar módulo: {e}")
            return False
    
    def search_modules(self, query, search_fields=['name', 'description', 'author']):
        """Busca módulos por query"""
        results = []
        query_lower = query.lower()
        
        for module_name, module_info in self.modules.items():
            for field in search_fields:
                if hasattr(module_info, field):
                    field_value = getattr(module_info, field)
                    if isinstance(field_value, str) and query_lower in field_value.lower():
                        results.append(module_info)
                        break
                elif field in module_info.metadata:
                    metadata_value = module_info.metadata[field]
                    if isinstance(metadata_value, str) and query_lower in metadata_value.lower():
                        results.append(module_info)
                        break
        
        return results
    
    def generate_module_report(self, module_name=None, output_format='html'):
        """Gera relatório dos módulos"""
        if module_name:
            modules = [self.modules.get(module_name)]
            if not modules[0]:
                self.logger.error(f"Módulo não encontrado: {module_name}")
                return None
        else:
            modules = list(self.modules.values())
        
        # Obtém estatísticas
        stats = self.get_module_stats()
        
        if output_format == 'html':
            return self._generate_html_module_report(modules, stats)
        elif output_format == 'json':
            return self._generate_json_module_report(modules, stats)
        elif output_format == 'csv':
            return self._generate_csv_module_report(modules, stats)
        else:
            self.logger.error(f"Formato não suportado: {output_format}")
            return None
    
    def _generate_html_module_report(self, modules, stats):
        """Gera relatório HTML dos módulos"""
        html = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Leonardo OSINT - Relatório de Módulos</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .header { background-color: #2c3e50; color: white; padding: 20px; border-radius: 5px; }
                .module { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
                .enabled { border-left: 5px solid #27ae60; }
                .disabled { border-left: 5px solid #e74c3c; }
                .error { border-left: 5px solid #f39c12; }
                .stats { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin: 20px 0; }
                table { width: 100%; border-collapse: collapse; }
                th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
                th { background-color: #f2f2f2; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Leonardo Pereira OSINT Suite</h1>
                <h2>Relatório de Módulos</h2>
                <p>Gerado em: """ + datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') + """</p>
            </div>
            
            <div class="stats">
                <h3>Estatísticas Gerais</h3>
                <p>Total de módulos: """ + str(len(modules)) + """</p>
                <p>Módulos habilitados: """ + str(len([m for m in modules if m.enabled])) + """</p>
                <p>Módulos carregados: """ + str(len(self.loaded_modules)) + """</p>
            </div>
            
            <h3>Módulos</h3>
        """
        
        for module in modules:
            module_class = "module"
            if module.status == self.ModuleStatus.ERROR:
                module_class += " error"
            elif module.enabled:
                module_class += " enabled"
            else:
                module_class += " disabled"
            
            module_stats = stats.get(module.name, {})
            
            html += f"""
            <div class="{module_class}">
                <h4>{module.name} v{module.version}</h4>
                <p><strong>Tipo:</strong> {module.type.value}</p>
                <p><strong>Autor:</strong> {module.author}</p>
                <p><strong>Descrição:</strong> {module.description}</p>
                <p><strong>Status:</strong> {module.status.value}</p>
                <p><strong>Habilitado:</strong> {'Sim' if module.enabled else 'Não'}</p>
                
                <h5>Estatísticas</h5>
                <table>
                    <tr><th>Execuções</th><th>Sucessos</th><th>Erros</th><th>Taxa de Sucesso</th><th>Tempo Médio</th></tr>
                    <tr>
                        <td>{module_stats.get('execution_count', 0)}</td>
                        <td>{module_stats.get('success_count', 0)}</td>
                        <td>{module_stats.get('error_count', 0)}</td>
                        <td>{module_stats.get('success_rate', 0):.1f}%</td>
                        <td>{module_stats.get('average_execution_time', 0):.2f}s</td>
                    </tr>
                </table>
                
                <h5>Dependências</h5>
                <ul>
            """
            
            for dep in module.dependencies:
                html += f"<li>{dep}</li>"
            
            html += """
                </ul>
                
                <h5>APIs Necessárias</h5>
                <ul>
            """
            
            for api in module.required_apis:
                html += f"<li>{api}</li>"
            
            html += """
                </ul>
            </div>
            """
        
        html += """
            <footer>
                <p>Report gerado automaticamente pela Leonardo Pereira OSINT Suite</p>
                <p>Desenvolvido por Leonardo Pereira</p>
            </footer>
        </body>
        </html>
        """
        
        # Salva arquivo
        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"module_report_{timestamp}.html"
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(html)
        
        self.logger.info(f"Relatório de módulos gerado: {filename}")
        return filename
    
    def _generate_json_module_report(self, modules, stats):
        """Gera relatório JSON dos módulos"""
        report = {
            'generated_at': datetime.datetime.now().isoformat(),
            'total_modules': len(modules),
            'enabled_modules': len([m for m in modules if m.enabled]),
            'loaded_modules': len(self.loaded_modules),
            'modules': []
        }
        
        for module in modules:
            module_stats = stats.get(module.name, {})
            
            module_info = {
                'name': module.name,
                'type': module.type.value,
                'version': module.version,
                'author': module.author,
                'description': module.description,
                'status': module.status.value,
                'enabled': module.enabled,
                'dependencies': module.dependencies,
                'required_apis': module.required_apis,
                'permissions': module.permissions.value,
                'path': module.path,
                'statistics': module_stats
            }
            
            report['modules'].append(module_info)
        
        # Salva arquivo
        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"module_report_{timestamp}.json"
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        self.logger.info(f"Relatório de módulos gerado: {filename}")
        return filename
    
    def _generate_csv_module_report(self, modules, stats):
        """Gera relatório CSV dos módulos"""
        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"module_report_{timestamp}.csv"
        
        with open(filename, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow([
                'Name', 'Type', 'Version', 'Author', 'Description',
                'Status', 'Enabled', 'Executions', 'Successes', 'Errors',
                'Success Rate', 'Avg Time', 'Dependencies', 'Required APIs'
            ])
            
            for module in modules:
                module_stats = stats.get(module.name, {})
                
                writer.writerow([
                    module.name,
                    module.type.value,
                    module.version,
                    module.author,
                    module.description[:100],  # Limita tamanho
                    module.status.value,
                    'Yes' if module.enabled else 'No',
                    module_stats.get('execution_count', 0),
                    module_stats.get('success_count', 0),
                    module_stats.get('error_count', 0),
                    f"{module_stats.get('success_rate', 0):.1f}%",
                    f"{module_stats.get('average_execution_time', 0):.2f}s",
                    ';'.join(module.dependencies),
                    ';'.join(module.required_apis)
                ])
        
        self.logger.info(f"Relatório de módulos gerado: {filename}")
        return filename

# ============================================================================
# ARQUITETURA DA APLICAÇÃO PRINCIPAL (1.000+ linhas)
# ============================================================================

class LeonardoOSINTApp:
    """Aplicação principal Leonardo Pereira OSINT Suite"""
    
    def __init__(self):
        """Inicializa a aplicação"""
        print(LeonardoConstants.Colors.BLUE + """
        ╔═══════════════════════════════════════════════════════════════════════╗
        ║                                                                       ║
        ║    ██╗     ███████╗ ██████╗ ███╗   ██╗ █████╗ ██████╗ ██████╗        ║
        ║    ██║     ██╔════╝██╔═══██╗████╗  ██║██╔══██╗██╔══██╗██╔══██╗       ║
        ║    ██║     █████╗  ██║   ██║██╔██╗ ██║███████║██████╔╝██║  ██║       ║
        ║    ██║     ██╔══╝  ██║   ██║██║╚██╗██║██╔══██║██╔══██╗██║  ██║       ║
        ║    ███████╗███████╗╚██████╔╝██║ ╚████║██║  ██║██║  ██║██████╔╝       ║
        ║    ╚══════╝╚══════╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝  ╚═╝╚═════╝        ║
        ║                                                                       ║
        ║          P E R E I R A   O S I N T   S U I T E   v5.0                 ║
        ║                                                                       ║
        ║              Ferramenta Avançada de Inteligência                      ║
        ║                 Desenvolvido por: Leonardo Pereira                     ║
        ║                                                                       ║
        ╚═══════════════════════════════════════════════════════════════════════╝
        """ + LeonardoConstants.Colors.RESET)
        
        # Inicializa componentes principais
        self.config = None
        self.logger = None
        self.module_manager = None
        self.database = None
        self.api_manager = None
        self.ui = None
        
        self._initialize_components()
    
    def _initialize_components(self):
        """Inicializa todos os componentes da aplicação"""
        try:
            # 1. Configuração
            print("[1/6] Inicializando sistema de configuração...")
            self.config = LeonardoConfig()
            
            # 2. Logging
            print("[2/6] Inicializando sistema de logging...")
            log_level_str = self.config.get('Logging', 'log_level', 'INFO')
            log_level = getattr(LeonardoLogger.LogLevel, log_level_str, LeonardoLogger.LogLevel.INFO)
            self.logger = LeonardoLogger("LeonardoOSINT", log_level)
            
            # 3. Gerenciador de módulos
            print("[3/6] Inicializando gerenciador de módulos...")
            self.module_manager = LeonardoModuleManager(self.config)
            
            # 4. Banco de dados
            print("[4/6] Inicializando sistema de banco de dados...")
            self._init_database()
            
            # 5. Gerenciador de APIs
            print("[5/6] Inicializando gerenciador de APIs...")
            self._init_api_manager()
            
            # 6. Interface do usuário
            print("[6/6] Inicializando interface do usuário...")
            self._init_ui()
            
            self.logger.logger.info("Leonardo Pereira OSINT Suite inicializada com sucesso!")
            self.logger.log_audit(
                "Aplicação inicializada",
                user=getpass.getuser(),
                ip=socket.gethostbyname(socket.gethostname()),
                action="startup"
            )
            
        except Exception as e:
            print(f"Erro fatal durante inicialização: {e}")
            traceback.print_exc()
            sys.exit(1)
    
    def _init_database(self):
        """Inicializa sistema de banco de dados"""
        # Implementação do banco de dados principal
        pass
    
    def _init_api_manager(self):
        """Inicializa gerenciador de APIs"""
        # Implementação do gerenciador de APIs
        pass
    
    def _init_ui(self):
        """Inicializa interface do usuário"""
        # Implementação da interface
        pass
    
    def run(self):
        """Executa a aplicação"""
        try:
            # Verifica aceitação dos termos
            if not self.config.get('Legal', 'terms_accepted', False):
                self._show_legal_disclaimer()
            
            # Menu principal
            self._main_menu()
            
        except KeyboardInterrupt:
            self.logger.logger.info("Aplicação interrompida pelo usuário")
            print("\n\nAplicação interrompida. Até logo!")
        except Exception as e:
            self.logger.logger.error(f"Erro na aplicação: {e}", exc_info=True)
            print(f"\nErro crítico: {e}")
    
    def _show_legal_disclaimer(self):
        """Exibe aviso legal e requer aceitação"""
        print("\n" + "="*80)
        print("AVISO LEGAL E TERMOS DE USO".center(80))
        print("="*80)
        
        disclaimer = self.config.get('Legal', 'legal_disclaimer', '')
        print("\n" + textwrap.fill(disclaimer, width=80))
        
        print("\n" + "="*80)
        print("DIRETRIZES ÉTICAS".center(80))
        print("="*80)
        
        guidelines = self.config.get('Legal', 'ethical_guidelines', '')
        print("\n" + textwrap.fill(guidelines, width=80))
        
        print("\n" + "="*80)
        
        while True:
            response = input("\nVocê aceita os termos e diretrizes acima? (s/n): ").lower()
            if response in ['s', 'sim', 'y', 'yes']:
                self.config.set('Legal', 'terms_accepted', True)
                self.config.set('Legal', 'privacy_policy_accepted', True)
                self.config.set('Legal', 'data_processing_consent', True)
                self.config.save()
                print("\nTermos aceitos. Continuando...")
                break
            elif response in ['n', 'não', 'no']:
                print("\nTermos não aceitos. Encerrando aplicação.")
                sys.exit(0)
            else:
                print("Resposta inválida. Por favor, responda com 's' ou 'n'.")
    
    def _main_menu(self):
        """Menu principal da aplicação"""
        while True:
            print("\n" + "="*80)
            print("MENU PRINCIPAL - LEONARDO PEREIRA OSINT SUITE".center(80))
            print("="*80)
            
            print("\nSelecione uma opção:")
            print("  1. Investigação OSINT")
            print("  2. Gerenciar Módulos")
            print("  3. Configurações")
            print("  4. Relatórios e Exportação")
            print("  5. Ferramentas Auxiliares")
            print("  6. Monitoramento")
            print("  7. Automatização")
            print("  8. Sistema")
            print("  9. Sair")
            
            choice = input("\nOpção: ").strip()
            
            if choice == '1':
                self._osint_investigation_menu()
            elif choice == '2':
                self._module_management_menu()
            elif choice == '3':
                self._configuration_menu()
            elif choice == '4':
                self._reports_menu()
            elif choice == '5':
                self._tools_menu()
            elif choice == '6':
                self._monitoring_menu()
            elif choice == '7':
                self._automation_menu()
            elif choice == '8':
                self._system_menu()
            elif choice == '9':
                print("\nEncerrando aplicação...")
                self._shutdown()
                break
            else:
                print("Opção inválida. Tente novamente.")
    
    def _osint_investigation_menu(self):
        """Menu de investigação OSINT"""
        while True:
            print("\n" + "-"*60)
            print("INVESTIGAÇÃO OSINT".center(60))
            print("-"*60)
            
            print("\nTipos de investigação:")
            print("  1. Pessoa / Usuário")
            print("  2. Domínio / Website")
            print("  3. Email")
            print("  4. Número de Telefone")
            print("  5. Endereço IP")
            print("  6. Imagem / Mídia")
            print("  7. Empresa / Organização")
            print("  8. Localização Geográfica")
            print("  9. Criptomoedas / Blockchain")
            print("  10. Investigação Completa")
            print("  11. Voltar")
            
            choice = input("\nTipo de investigação: ").strip()
            
            if choice == '11':
                break
            
            if choice in ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']:
                target = input("\nAlvo da investigação: ").strip()
                if target:
                    self._perform_investigation(choice, target)
                else:
                    print("Alvo não especificado.")
            else:
                print("Opção inválida.")
    
    def _perform_investigation(self, investigation_type, target):
        """Executa uma investigação"""
        print(f"\nIniciando investigação para: {target}")
        
        # Mapeia tipo para módulos
        module_map = {
            '1': ['social_media', 'email_intel', 'username_enum'],  # Pessoa
            '2': ['domain_intel', 'subdomain_enum', 'port_scan'],   # Domínio
            '3': ['email_intel', 'breach_check', 'social_media'],   # Email
            '4': ['phone_intel', 'carrier_lookup', 'social_media'], # Telefone
            '5': ['ip_geolocation', 'whois', 'threat_intel'],       # IP
            '6': ['image_analysis', 'reverse_image', 'exif'],       # Imagem
            '7': ['company_intel', 'domain_intel', 'social_media'], # Empresa
            '8': ['geolocation', 'satellite_imagery', 'maps'],      # Localização
            '9': ['blockchain_analysis', 'crypto_tracking'],        # Blockchain
            '10': 'all'  # Todos os módulos
        }
        
        modules_to_run = module_map.get(investigation_type, [])
        
        if modules_to_run == 'all':
            results = self.module_manager.execute_all_modules(target)
        else:
            results = self.module_manager.execute_multiple_modules(modules_to_run, target)
        
        # Exibe resultados
        self._display_investigation_results(results, target)
    
    def _display_investigation_results(self, results, target):
        """Exibe resultados da investigação"""
        print(f"\n{'='*80}")
        print(f"RESULTADOS DA INVESTIGAÇÃO: {target}".center(80))
        print(f"{'='*80}")
        
        total_results = 0
        successful_modules = 0
        
        for module_name, result in results.items():
            if result.get('success', False):
                successful_modules += 1
                result_count = len(result.get('results', []))
                total_results += result_count
                
                print(f"\n[{module_name.upper()}]")
                print(f"  Status: {LeonardoConstants.Colors.GREEN}SUCESSO{LeonardoConstants.Colors.RESET}")
                print(f"  Resultados: {result_count}")
                print(f"  Tempo de execução: {result.get('execution_time', 0):.2f}s")
                
                # Exibe primeiros resultados
                for i, res in enumerate(result.get('results', [])[:3]):
                    print(f"  [{i+1}] {res.get('type', 'unknown')}: {str(res.get('data', ''))[:80]}...")
                
                if result_count > 3:
                    print(f"  ... e mais {result_count - 3} resultados")
            else:
                print(f"\n[{module_name.upper()}]")
                print(f"  Status: {LeonardoConstants.Colors.RED}FALHA{LeonardoConstants.Colors.RESET}")
                for error in result.get('errors', []):
                    print(f"  Erro: {error}")
        
        print(f"\n{'='*80}")
        print(f"RESUMO".center(80))
        print(f"{'='*80}")
        print(f"Módulos executados: {len(results)}")
        print(f"Módulos com sucesso: {successful_modules}")
        print(f"Total de resultados: {total_results}")
        
        # Pergunta se quer salvar resultados
        save = input("\nDeseja salvar os resultados? (s/n): ").lower()
        if save in ['s', 'sim', 'y', 'yes']:
            self._save_investigation_results(results, target)
    
    def _save_investigation_results(self, results, target):
        """Salva resultados da investigação"""
        print("\nFormatos de exportação:")
        print("  1. JSON")
        print("  2. HTML")
        print("  3. PDF")
        print("  4. CSV")
        print("  5. Todos os formatos")
        
        choice = input("\nFormato: ").strip()
        
        formats = []
        if choice == '1':
            formats = ['json']
        elif choice == '2':
            formats = ['html']
        elif choice == '3':
            formats = ['pdf']
        elif choice == '4':
            formats = ['csv']
        elif choice == '5':
            formats = ['json', 'html', 'csv']
        else:
            print("Opção inválida.")
            return
        
        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        base_filename = f"investigation_{target}_{timestamp}"
        
        for fmt in formats:
            filename = f"{base_filename}.{fmt}"
            
            # Combina todos os resultados
            all_results = []
            for module_name, result in results.items():
                if result.get('success', False):
                    for res in result.get('results', []):
                        res['module'] = module_name
                        all_results.append(res)
            
            # Salva no formato especificado
            if fmt == 'json':
                data = {
                    'target': target,
                    'generated_at': datetime.datetime.now().isoformat(),
                    'modules_executed': list(results.keys()),
                    'results': all_results
                }
                
                with open(filename, 'w', encoding='utf-8') as f:
                    json.dump(data, f, indent=2, ensure_ascii=False)
                
                print(f"Resultados salvos como JSON: {filename}")
            
            elif fmt == 'html':
                # Gera relatório HTML
                html = self._generate_html_report(target, results, all_results)
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(html)
                
                print(f"Resultados salvos como HTML: {filename}")
            
            elif fmt == 'csv':
                # Gera CSV
                with open(filename, 'w', newline='', encoding='utf-8') as f:
                    writer = csv.writer(f)
                    writer.writerow(['Module', 'Type', 'Data', 'Confidence', 'Source', 'Timestamp'])
                    
                    for result in all_results:
                        writer.writerow([
                            result.get('module', ''),
                            result.get('type', ''),
                            str(result.get('data', ''))[:500],
                            result.get('confidence', 0),
                            result.get('source', ''),
                            result.get('timestamp', '')
                        ])
                
                print(f"Resultados salvos como CSV: {filename}")
    
    def _generate_html_report(self, target, module_results, all_results):
        """Gera relatório HTML completo"""
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Leonardo OSINT Report - {target}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background-color: #2c3e50; color: white; padding: 20px; border-radius: 5px; }}
                .module {{ border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }}
                .success {{ border-left: 5px solid #27ae60; }}
                .failure {{ border-left: 5px solid #e74c3c; }}
                .result {{ margin: 10px 0; padding: 10px; background-color: #f8f9fa; border-radius: 3px; }}
                table {{ width: 100%; border-collapse: collapse; margin: 20px 0; }}
                th, td {{ padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }}
                th {{ background-color: #f2f2f2; }}
                .summary {{ background-color: #e8f4fd; padding: 15px; border-radius: 5px; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Leonardo Pereira OSINT Suite</h1>
                <h2>Relatório de Investigação: {target}</h2>
                <p>Gerado em: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            </div>
            
            <div class="summary">
                <h3>Resumo da Investigação</h3>
                <p><strong>Alvo:</strong> {target}</p>
                <p><strong>Total de módulos executados:</strong> {len(module_results)}</p>
                <p><strong>Total de resultados coletados:</strong> {len(all_results)}</p>
            </div>
            
            <h3>Resultados por Módulo</h3>
        """
        
        for module_name, result in module_results.items():
            status_class = "success" if result.get('success', False) else "failure"
            status_text = "SUCESSO" if result.get('success', False) else "FALHA"
            
            html += f"""
            <div class="module {status_class}">
                <h4>{module_name.upper()} - {status_text}</h4>
                <p><strong>Resultados:</strong> {len(result.get('results', []))}</p>
                <p><strong>Tempo de execução:</strong> {result.get('execution_time', 0):.2f}s</p>
            """
            
            if result.get('success', False):
                html += "<h5>Principais Resultados:</h5>"
                for i, res in enumerate(result.get('results', [])[:5]):
                    html += f"""
                    <div class="result">
                        <strong>{res.get('type', 'unknown')}</strong>
                        <p>{res.get('data', '')}</p>
                        <small>Confiança: {res.get('confidence', 0)} | Fonte: {res.get('source', 'unknown')}</small>
                    </div>
                    """
                
                if len(result.get('results', [])) > 5:
                    html += f"<p>... e mais {len(result.get('results', [])) - 5} resultados</p>"
            
            html += "</div>"
        
        # Tabela de todos os resultados
        html += """
            <h3>Todos os Resultados</h3>
            <table>
                <tr>
                    <th>Módulo</th>
                    <th>Tipo</th>
                    <th>Dados</th>
                    <th>Confiança</th>
                    <th>Fonte</th>
                </tr>
        """
        
        for result in all_results[:100]:  # Limita a 100 resultados na tabela
            html += f"""
                <tr>
                    <td>{result.get('module', '')}</td>
                    <td>{result.get('type', '')}</td>
                    <td>{str(result.get('data', ''))[:200]}</td>
                    <td>{result.get('confidence', 0)}</td>
                    <td>{result.get('source', '')}</td>
                </tr>
            """
        
        if len(all_results) > 100:
            html += f"""
                <tr>
                    <td colspan="5">... e mais {len(all_results) - 100} resultados</td>
                </tr>
            """
        
        html += """
            </table>
            
            <footer>
                <p>Report gerado automaticamente pela Leonardo Pereira OSINT Suite v5.0</p>
                <p>Desenvolvido por Leonardo Pereira - Uso autorizado apenas para pesquisas legítimas</p>
            </footer>
        </body>
        </html>
        """
        
        return html
    
    def _module_management_menu(self):
        """Menu de gerenciamento de módulos"""
        while True:
            print("\n" + "-"*60)
            print("GERENCIAMENTO DE MÓDULOS".center(60))
            print("-"*60)
            
            print("\nOpções:")
            print("  1. Listar todos os módulos")
            print("  2. Habilitar/desabilitar módulo")
            print("  3. Executar módulo específico")
            print("  4. Instalar novo módulo")
            print("  5. Desinstalar módulo")
            print("  6. Atualizar módulo")
            print("  7. Gerar relatório de módulos")
            print("  8. Voltar")
            
            choice = input("\nOpção: ").strip()
            
            if choice == '1':
                self._list_modules()
            elif choice == '2':
                self._toggle_module()
            elif choice == '3':
                self._run_specific_module()
            elif choice == '4':
                self._install_module()
            elif choice == '5':
                self._uninstall_module()
            elif choice == '6':
                self._update_module()
            elif choice == '7':
                self._generate_module_report()
            elif choice == '8':
                break
            else:
                print("Opção inválida.")
    
    def _list_modules(self):
        """Lista todos os módulos"""
        modules = self.module_manager.get_all_modules()
        
        print(f"\n{'='*80}")
        print(f"MÓDULOS DISPONÍVEIS ({len(modules)})".center(80))
        print(f"{'='*80}")
        
        for module in modules:
            status_color = LeonardoConstants.Colors.GREEN if module.enabled else LeonardoConstants.Colors.RED
            status_text = "HABILITADO" if module.enabled else "DESABILITADO"
            
            print(f"\n{module.name} v{module.version}")
            print(f"  Tipo: {module.type.value}")
            print(f"  Autor: {module.author}")
            print(f"  Status: {status_color}{status_text}{LeonardoConstants.Colors.RESET}")
            print(f"  Descrição: {module.description[:100]}...")
            
            # Estatísticas
            stats = self.module_manager.get_module_stats(module.name)
            if module.name in stats:
                stat = stats[module.name]
                print(f"  Execuções: {stat['execution_count']} | Taxa de sucesso: {stat['success_rate']:.1f}%")
    
    def _toggle_module(self):
        """Habilita/desabilita um módulo"""
        module_name = input("\nNome do módulo: ").strip()
        
        module = self.module_manager.get_module(module_name)
        if not module:
            print(f"Módulo '{module_name}' não encontrado.")
            return
        
        if module.enabled:
            confirm = input(f"Desabilitar módulo '{module_name}'? (s/n): ").lower()
            if confirm in ['s', 'sim', 'y', 'yes']:
                self.module_manager.disable_module(module_name)
                print(f"Módulo '{module_name}' desabilitado.")
        else:
            confirm = input(f"Habilitar módulo '{module_name}'? (s/n): ").lower()
            if confirm in ['s', 'sim', 'y', 'yes']:
                self.module_manager.enable_module(module_name)
                print(f"Módulo '{module_name}' habilitado.")
    
    def _run_specific_module(self):
        """Executa um módulo específico"""
        module_name = input("\nNome do módulo: ").strip()
        target = input("Alvo: ").strip()
        
        if not target:
            print("Alvo não especificado.")
            return
        
        print(f"\nExecutando módulo '{module_name}' no alvo '{target}'...")
        
        result = self.module_manager.execute_module(module_name, target)
        
        if result.get('success', False):
            print(f"\n{LeonardoConstants.Colors.GREEN}Módulo executado com sucesso!{LeonardoConstants.Colors.RESET}")
            print(f"Resultados: {len(result.get('results', []))}")
            print(f"Tempo de execução: {result.get('execution_time', 0):.2f}s")
            
            # Exibe primeiros resultados
            for i, res in enumerate(result.get('results', [])[:5]):
                print(f"\n[{i+1}] {res.get('type', 'unknown')}:")
                print(f"    {str(res.get('data', ''))[:200]}")
        else:
            print(f"\n{LeonardoConstants.Colors.RED}Falha na execução do módulo.{LeonardoConstants.Colors.RESET}")
            for error in result.get('errors', []):
                print(f"  Erro: {error}")
    
    def _install_module(self):
        """Instala um novo módulo"""
        print("\nFontes de instalação:")
        print("  1. URL (GitHub, etc.)")
        print("  2. Diretório local")
        print("  3. Arquivo ZIP local")
        
        source_type = input("\nTipo de fonte: ").strip()
        
        if source_type == '1':
            url = input("URL do módulo: ").strip()
            source = url
        elif source_type == '2':
            directory = input("Caminho do diretório: ").strip()
            source = directory
        elif source_type == '3':
            zip_file = input("Caminho do arquivo ZIP: ").strip()
            source = zip_file
        else:
            print("Tipo inválido.")
            return
        
        print(f"\nInstalando módulo de: {source}")
        
        if self.module_manager.install_module(source):
            print(f"{LeonardoConstants.Colors.GREEN}Módulo instalado com sucesso!{LeonardoConstants.Colors.RESET}")
        else:
            print(f"{LeonardoConstants.Colors.RED}Falha na instalação do módulo.{LeonardoConstants.Colors.RESET}")
    
    def _uninstall_module(self):
        """Desinstala um módulo"""
        module_name = input("\nNome do módulo para desinstalar: ").strip()
        
        confirm = input(f"Tem certeza que deseja desinstalar '{module_name}'? (s/n): ").lower()
        if confirm not in ['s', 'sim', 'y', 'yes']:
            print("Operação cancelada.")
            return
        
        if self.module_manager.uninstall_module(module_name):
            print(f"{LeonardoConstants.Colors.GREEN}Módulo desinstalado com sucesso!{LeonardoConstants.Colors.RESET}")
        else:
            print(f"{LeonardoConstants.Colors.RED}Falha na desinstalação do módulo.{LeonardoConstants.Colors.RESET}")
    
    def _update_module(self):
        """Atualiza um módulo"""
        module_name = input("\nNome do módulo para atualizar: ").strip()
        
        print("\nFonte de atualização (deixe em branco para usar fonte padrão):")
        source = input("URL ou caminho: ").strip()
        
        if source:
            if self.module_manager.update_module(module_name, source):
                print(f"{LeonardoConstants.Colors.GREEN}Módulo atualizado com sucesso!{LeonardoConstants.Colors.RESET}")
            else:
                print(f"{LeonardoConstants.Colors.RED}Falha na atualização do módulo.{LeonardoConstants.Colors.RESET}")
        else:
            if self.module_manager.update_module(module_name):
                print(f"{LeonardoConstants.Colors.GREEN}Módulo atualizado com sucesso!{LeonardoConstants.Colors.RESET}")
            else:
                print(f"{LeonardoConstants.Colors.RED}Falha na atualização do módulo.{LeonardoConstants.Colors.RESET}")
    
    def _generate_module_report(self):
        """Gera relatório de módulos"""
        module_name = input("\nNome do módulo (deixe em branco para todos): ").strip()
        
        print("\nFormatos de relatório:")
        print("  1. HTML")
        print("  2. JSON")
        print("  3. CSV")
        
        format_choice = input("\nFormato: ").strip()
        
        if format_choice == '1':
            output_format = 'html'
        elif format_choice == '2':
            output_format = 'json'
        elif format_choice == '3':
            output_format = 'csv'
        else:
            print("Formato inválido.")
            return
        
        if module_name:
            filename = self.module_manager.generate_module_report(module_name, output_format)
        else:
            filename = self.module_manager.generate_module_report(output_format=output_format)
        
        if filename:
            print(f"{LeonardoConstants.Colors.GREEN}Relatório gerado: {filename}{LeonardoConstants.Colors.RESET}")
        else:
            print(f"{LeonardoConstants.Colors.RED}Falha ao gerar relatório.{LeonardoConstants.Colors.RESET}")
    
    def _configuration_menu(self):
        """Menu de configuração"""
        while True:
            print("\n" + "-"*60)
            print("CONFIGURAÇÕES".center(60))
            print("-"*60)
            
            print("\nSeções:")
            for i, section in enumerate(self.config.list_sections(), 1):
                print(f"  {i}. {section}")
            
            print(f"  {len(self.config.list_sections()) + 1}. Exportar configurações")
            print(f"  {len(self.config.list_sections()) + 2}. Importar configurações")
            print(f"  {len(self.config.list_sections()) + 3}. Redefinir para padrão")
            print(f"  {len(self.config.list_sections()) + 4}. Voltar")
            
            try:
                choice = int(input("\nSeção: ").strip())
            except ValueError:
                print("Opção inválida.")
                continue
            
            sections = self.config.list_sections()
            
            if 1 <= choice <= len(sections):
                section_name = sections[choice - 1]
                self._edit_config_section(section_name)
            elif choice == len(sections) + 1:
                self._export_configuration()
            elif choice == len(sections) + 2:
                self._import_configuration()
            elif choice == len(sections) + 3:
                self._reset_configuration()
            elif choice == len(sections) + 4:
                break
            else:
                print("Opção inválida.")
    
    def _edit_config_section(self, section_name):
        """Edita uma seção de configuração"""
        while True:
            print(f"\n{'='*60}")
            print(f"CONFIGURAÇÃO: {section_name.upper()}".center(60))
            print(f"{'='*60}")
            
            section_data = self.config.get_section(section_name)
            
            # Lista chaves
            keys = list(section_data.keys())
            for i, key in enumerate(keys, 1):
                value = section_data[key]
                print(f"  {i}. {key} = {str(value)[:50]}")
            
            print(f"  {len(keys) + 1}. Editar chave")
            print(f"  {len(keys) + 2}. Adicionar nova chave")
            print(f"  {len(keys) + 3}. Voltar")
            
            try:
                choice = int(input("\nOpção: ").strip())
            except ValueError:
                print("Opção inválida.")
                continue
            
            if 1 <= choice <= len(keys):
                key_name = keys[choice - 1]
                self._edit_config_key(section_name, key_name)
            elif choice == len(keys) + 1:
                self._edit_custom_key(section_name)
            elif choice == len(keys) + 2:
                self._add_config_key(section_name)
            elif choice == len(keys) + 3:
                break
            else:
                print("Opção inválida.")
    
    def _edit_config_key(self, section_name, key_name):
        """Edita uma chave de configuração"""
        current_value = self.config.get(section_name, key_name)
        print(f"\nChave: {key_name}")
        print(f"Valor atual: {current_value}")
        
        new_value = input("Novo valor (deixe em branco para cancelar): ").strip()
        
        if new_value:
            try:
                self.config.set(section_name, key_name, new_value)
                self.config.save()
                print(f"{LeonardoConstants.Colors.GREEN}Chave atualizada com sucesso!{LeonardoConstants.Colors.RESET}")
            except Exception as e:
                print(f"{LeonardoConstants.Colors.RED}Erro ao atualizar chave: {e}{LeonardoConstants.Colors.RESET}")
    
    def _edit_custom_key(self, section_name):
        """Edita uma chave personalizada"""
        key_name = input("\nNome da chave para editar: ").strip()
        
        if not key_name:
            print("Nome da chave não especificado.")
            return
        
        if not self.config.has_key(section_name, key_name):
            print(f"Chave '{key_name}' não encontrada na seção '{section_name}'.")
            return
        
        self._edit_config_key(section_name, key_name)
    
    def _add_config_key(self, section_name):
        """Adiciona uma nova chave de configuração"""
        key_name = input("\nNome da nova chave: ").strip()
        
        if not key_name:
            print("Nome da chave não especificado.")
            return
        
        if self.config.has_key(section_name, key_name):
            print(f"Chave '{key_name}' já existe.")
            return
        
        value = input("Valor: ").strip()
        
        if value:
            try:
                self.config.set(section_name, key_name, value)
                self.config.save()
                print(f"{LeonardoConstants.Colors.GREEN}Chave adicionada com sucesso!{LeonardoConstants.Colors.RESET}")
            except Exception as e:
                print(f"{LeonardoConstants.Colors.RED}Erro ao adicionar chave: {e}{LeonardoConstants.Colors.RESET}")
    
    def _export_configuration(self):
        """Exporta configurações"""
        print("\nFormatos de exportação:")
        print("  1. JSON")
        print("  2. YAML")
        print("  3. INI")
        
        format_choice = input("\nFormato: ").strip()
        
        if format_choice == '1':
            file_format = 'json'
        elif format_choice == '2':
            file_format = 'yaml'
        elif format_choice == '3':
            file_format = 'ini'
        else:
            print("Formato inválido.")
            return
        
        filename = input("Nome do arquivo (deixe em branco para padrão): ").strip()
        
        exported_file = self.config.export(file_format, filename)
        if exported_file:
            print(f"{LeonardoConstants.Colors.GREEN}Configurações exportadas para: {exported_file}{LeonardoConstants.Colors.RESET}")
        else:
            print(f"{LeonardoConstants.Colors.RED}Falha ao exportar configurações.{LeonardoConstants.Colors.RESET}")
    
    def _import_configuration(self):
        """Importa configurações"""
        filename = input("\nCaminho do arquivo de configuração: ").strip()
        
        if not os.path.exists(filename):
            print(f"Arquivo não encontrado: {filename}")
            return
        
        merge = input("Mesclar com configurações existentes? (s/n): ").lower()
        merge = merge in ['s', 'sim', 'y', 'yes']
        
        if self.config.import_config(filename, merge):
            print(f"{LeonardoConstants.Colors.GREEN}Configurações importadas com sucesso!{LeonardoConstants.Colors.RESET}")
        else:
            print(f"{LeonardoConstants.Colors.RED}Falha ao importar configurações.{LeonardoConstants.Colors.RESET}")
    
    def _reset_configuration(self):
        """Redefine configurações para padrão"""
        section = input("\nSeção para redefinir (deixe em branco para todas): ").strip()
        
        confirm = input("Tem certeza? Isso irá substituir todas as configurações. (s/n): ").lower()
        if confirm not in ['s', 'sim', 'y', 'yes']:
            print("Operação cancelada.")
            return
        
        if section:
            if self.config.reset_to_defaults(section):
                print(f"{LeonardoConstants.Colors.GREEN}Seção '{section}' redefinida para padrão!{LeonardoConstants.Colors.RESET}")
            else:
                print(f"{LeonardoConstants.Colors.RED}Falha ao redefinir seção.{LeonardoConstants.Colors.RESET}")
        else:
            if self.config.reset_to_defaults():
                print(f"{LeonardoConstants.Colors.GREEN}Todas as configurações redefinidas para padrão!{LeonardoConstants.Colors.RESET}")
            else:
                print(f"{LeonardoConstants.Colors.RED}Falha ao redefinir configurações.{LeonardoConstants.Colors.RESET}")
    
    def _reports_menu(self):
        """Menu de relatórios"""
        print("\n" + "-"*60)
        print("RELATÓRIOS E EXPORTAÇÃO".center(60))
        print("-"*60)
        
        print("\nFuncionalidade em desenvolvimento...")
        input("\nPressione Enter para continuar...")
    
    def _tools_menu(self):
        """Menu de ferramentas auxiliares"""
        print("\n" + "-"*60)
        print("FERRAMENTAS AUXILIARES".center(60))
        print("-"*60)
        
        print("\nFuncionalidade em desenvolvimento...")
        input("\nPressione Enter para continuar...")
    
    def _monitoring_menu(self):
        """Menu de monitoramento"""
        print("\n" + "-"*60)
        print("MONITORAMENTO".center(60))
        print("-"*60)
        
        print("\nFuncionalidade em desenvolvimento...")
        input("\nPressione Enter para continuar...")
    
    def _automation_menu(self):
        """Menu de automação"""
        print("\n" + "-"*60)
        print("AUTOMAÇÃO".center(60))
        print("-"*60)
        
        print("\nFuncionalidade em desenvolvimento...")
        input("\nPressione Enter para continuar...")
    
    def _system_menu(self):
        """Menu do sistema"""
        while True:
            print("\n" + "-"*60)
            print("SISTEMA".center(60))
            print("-"*60)
            
            print("\nOpções:")
            print("  1. Status do sistema")
            print("  2. Limpar cache")
            print("  3. Backup de dados")
            print("  4. Restaurar backup")
            print("  5. Verificar atualizações")
            print("  6. Logs do sistema")
            print("  7. Informações técnicas")
            print("  8. Voltar")
            
            choice = input("\nOpção: ").strip()
            
            if choice == '1':
                self._system_status()
            elif choice == '2':
                self._clear_cache()
            elif choice == '3':
                self._backup_data()
            elif choice == '4':
                self._restore_backup()
            elif choice == '5':
                self._check_updates()
            elif choice == '6':
                self._system_logs()
            elif choice == '7':
                self._technical_info()
            elif choice == '8':
                break
            else:
                print("Opção inválida.")
    
    def _system_status(self):
        """Exibe status do sistema"""
        print(f"\n{'='*80}")
        print(f"STATUS DO SISTEMA".center(80))
        print(f"{'='*80}")
        
        # Informações básicas
        print(f"\n{LeonardoConstants.Colors.BOLD}Leonardo Pereira OSINT Suite v{LeonardoConstants.VERSION}{LeonardoConstants.Colors.RESET}")
        print(f"Inicializado em: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        # Módulos
        modules = self.module_manager.get_all_modules()
        enabled_modules = [m for m in modules if m.enabled]
        loaded_modules = len(self.module_manager.loaded_modules)
        
        print(f"\nMódulos:")
        print(f"  Total: {len(modules)}")
        print(f"  Habilitados: {len(enabled_modules)}")
        print(f"  Carregados: {loaded_modules}")
        
        # Estatísticas
        stats = self.module_manager.get_module_stats()
        total_executions = sum(stat['execution_count'] for stat in stats.values())
        total_success = sum(stat['success_count'] for stat in stats.values())
        success_rate = (total_success / total_executions * 100) if total_executions > 0 else 0
        
        print(f"\nExecuções:")
        print(f"  Total: {total_executions}")
        print(f"  Sucessos: {total_success}")
        print(f"  Taxa de sucesso: {success_rate:.1f}%")
        
        # Sistema
        import platform
        print(f"\nSistema:")
        print(f"  Sistema operacional: {platform.system()} {platform.release()}")
        print(f"  Python: {platform.python_version()}")
        
        # Memória
        try:
            import psutil
            memory = psutil.virtual_memory()
            print(f"  Memória: {memory.percent}% usado ({memory.used / (1024**3):.1f} GB / {memory.total / (1024**3):.1f} GB)")
            
            disk = psutil.disk_usage('/')
            print(f"  Disco: {disk.percent}% usado ({disk.used / (1024**3):.1f} GB / {disk.total / (1024**3):.1f} GB)")
        except ImportError:
            print(f"  Memória/Disco: psutil não instalado")
        
        print(f"\n{'='*80}")
        input("\nPressione Enter para continuar...")
    
    def _clear_cache(self):
        """Limpa cache do sistema"""
        cache_dir = self.config.get('Performance', 'cache_directory', 'cache')
        
        confirm = input(f"\nTem certeza que deseja limpar o cache em '{cache_dir}'? (s/n): ").lower()
        if confirm not in ['s', 'sim', 'y', 'yes']:
            print("Operação cancelada.")
            return
        
        try:
            import shutil
            if os.path.exists(cache_dir):
                shutil.rmtree(cache_dir)
                os.makedirs(cache_dir, exist_ok=True)
                print(f"{LeonardoConstants.Colors.GREEN}Cache limpo com sucesso!{LeonardoConstants.Colors.RESET}")
            else:
                print(f"Diretório de cache não encontrado: {cache_dir}")
        except Exception as e:
            print(f"{LeonardoConstants.Colors.RED}Erro ao limpar cache: {e}{LeonardoConstants.Colors.RESET}")
    
    def _backup_data(self):
        """Faz backup dos dados"""
        print("\nFuncionalidade em desenvolvimento...")
        input("Pressione Enter para continuar...")
    
    def _restore_backup(self):
        """Restaura backup"""
        print("\nFuncionalidade em desenvolvimento...")
        input("Pressione Enter para continuar...")
    
    def _check_updates(self):
        """Verifica atualizações"""
        print("\nFuncionalidade em desenvolvimento...")
        input("Pressione Enter para continuar...")
    
    def _system_logs(self):
        """Exibe logs do sistema"""
        log_dir = self.config.get('Logging', 'log_directory', 'logs')
        
        if not os.path.exists(log_dir):
            print(f"Diretório de logs não encontrado: {log_dir}")
            return
        
        print(f"\n{'='*80}")
        print(f"LOGS DO SISTEMA".center(80))
        print(f"{'='*80}")
        
        log_files = []
        for file in os.listdir(log_dir):
            if file.endswith('.log'):
                log_files.append(file)
        
        if not log_files:
            print("Nenhum arquivo de log encontrado.")
            return
        
        print("\nArquivos de log disponíveis:")
        for i, log_file in enumerate(log_files, 1):
            filepath = os.path.join(log_dir, log_file)
            size = os.path.getsize(filepath) if os.path.exists(filepath) else 0
            print(f"  {i}. {log_file} ({size / 1024:.1f} KB)")
        
        print(f"  {len(log_files) + 1}. Ver todos os logs recentes")
        print(f"  {len(log_files) + 2}. Limpar logs antigos")
        print(f"  {len(log_files) + 3}. Voltar")
        
        try:
            choice = int(input("\nOpção: ").strip())
        except ValueError:
            print("Opção inválida.")
            return
        
        if 1 <= choice <= len(log_files):
            log_file = log_files[choice - 1]
            self._view_log_file(os.path.join(log_dir, log_file))
        elif choice == len(log_files) + 1:
            self._view_recent_logs(log_dir)
        elif choice == len(log_files) + 2:
            self._cleanup_old_logs()
        elif choice == len(log_files) + 3:
            return
        else:
            print("Opção inválida.")
    
    def _view_log_file(self, log_file):
        """Visualiza um arquivo de log"""
        try:
            print(f"\n{'='*80}")
            print(f"LOG: {os.path.basename(log_file)}".center(80))
            print(f"{'='*80}")
            
            with open(log_file, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            # Mostra últimas 100 linhas
            start = max(0, len(lines) - 100)
            for line in lines[start:]:
                print(line.rstrip())
            
            print(f"\nTotal de linhas: {len(lines)}")
            print(f"Mostrando últimas {min(100, len(lines))} linhas")
            
        except Exception as e:
            print(f"Erro ao ler arquivo de log: {e}")
        
        input("\nPressione Enter para continuar...")
    
    def _view_recent_logs(self, log_dir):
        """Visualiza logs recentes de todos os arquivos"""
        try:
            print(f"\n{'='*80}")
            print(f"LOGS RECENTES".center(80))
            print(f"{'='*80}")
            
            # Coleta últimas linhas de todos os logs
            all_lines = []
            for file in os.listdir(log_dir):
                if file.endswith('.log'):
                    filepath = os.path.join(log_dir, file)
                    try:
                        with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                            lines = f.readlines()[-50:]  # Últimas 50 linhas de cada
                            for line in lines:
                                all_lines.append((file, line))
                    except:
                        pass
            
            # Ordena por timestamp (supondo formato de log padrão)
            def extract_timestamp(line):
                try:
                    # Tenta extrair timestamp do início da linha
                    return line[1][:19]  # Formato: YYYY-MM-DD HH:MM:SS
                except:
                    return "0000-00-00 00:00:00"
            
            all_lines.sort(key=extract_timestamp, reverse=True)
            
            # Mostra últimas 100 linhas
            for file, line in all_lines[:100]:
                print(f"{file}: {line.rstrip()}")
            
            print(f"\nTotal de entradas: {len(all_lines)}")
            print(f"Mostrando últimas {min(100, len(all_lines))} entradas")
            
        except Exception as e:
            print(f"Erro ao ler logs: {e}")
        
        input("\nPressione Enter para continuar...")
    
    def _cleanup_old_logs(self):
        """Limpa logs antigos"""
        days = input("\nDias para manter (padrão: 30): ").strip()
        
        try:
            days = int(days) if days else 30
        except ValueError:
            print("Número inválido.")
            return
        
        confirm = input(f"Remover logs com mais de {days} dias? (s/n): ").lower()
        if confirm not in ['s', 'sim', 'y', 'yes']:
            print("Operação cancelada.")
            return
        
        try:
            self.logger.cleanup_old_logs(days)
            print(f"{LeonardoConstants.Colors.GREEN}Logs antigos removidos!{LeonardoConstants.Colors.RESET}")
        except Exception as e:
            print(f"{LeonardoConstants.Colors.RED}Erro ao limpar logs: {e}{LeonardoConstants.Colors.RESET}")
    
    def _technical_info(self):
        """Exibe informações técnicas"""
        print(f"\n{'='*80}")
        print(f"INFORMAÇÕES TÉCNICAS".center(80))
        print(f"{'='*80}")
        
        # Informações da aplicação
        print(f"\n{LeonardoConstants.Colors.BOLD}Aplicação:{LeonardoConstants.Colors.RESET}")
        print(f"  Nome: Leonardo Pereira OSINT Suite")
        print(f"  Versão: {LeonardoConstants.VERSION}")
        print(f"  Autor: {LeonardoConstants.AUTHOR}")
        print(f"  Licença: {LeonardoConstants.LICENSE}")
        print(f"  Repositório: {LeonardoConstants.REPOSITORY}")
        
        # Python
        import platform
        print(f"\n{LeonardoConstants.Colors.BOLD}Python:{LeonardoConstants.Colors.RESET}")
        print(f"  Versão: {platform.python_version()}")
        print(f"  Implementação: {platform.python_implementation()}")
        print(f"  Compilador: {platform.python_compiler()}")
        
        # Sistema
        print(f"\n{LeonardoConstants.Colors.BOLD}Sistema:{LeonardoConstants.Colors.RESET}")
        print(f"  Sistema: {platform.system()} {platform.release()}")
        print(f"  Versão: {platform.version()}")
        print(f"  Máquina: {platform.machine()}")
        print(f"  Processador: {platform.processor()}")
        
        # Dependências
        print(f"\n{LeonardoConstants.Colors.BOLD}Dependências principais:{LeonardoConstants.Colors.RESET}")
        
        dependencies = [
            ('requests', 'HTTP requests'),
            ('beautifulsoup4', 'Web scraping'),
            ('selenium', 'Automação web'),
            ('pandas', 'Análise de dados'),
            ('numpy', 'Computação numérica'),
            ('matplotlib', 'Visualização'),
            ('networkx', 'Análise de redes'),
            ('Pillow', 'Processamento de imagem'),
            ('cryptography', 'Criptografia'),
            ('dnspython', 'DNS queries'),
            ('whois', 'WHOIS lookups'),
            ('scapy', 'Análise de rede'),
            ('paramiko', 'SSH client'),
            ('elasticsearch', 'Elasticsearch client'),
            ('pymongo', 'MongoDB client'),
            ('redis', 'Redis client'),
            ('celery', 'Task queue'),
            ('fastapi', 'API framework'),
            ('torch', 'Machine learning'),
            ('tensorflow', 'Deep learning'),
            ('transformers', 'NLP models'),
            ('spacy', 'NLP processing'),
            ('nltk', 'Natural language toolkit'),
            ('gensim', 'Topic modeling'),
            ('sklearn', 'Machine learning'),
        ]
        
        for dep, desc in dependencies:
            try:
                module = __import__(dep)
                version = getattr(module, '__version__', 'N/A')
                print(f"  {dep:20} {version:10} - {desc}")
            except ImportError:
                print(f"  {dep:20} {'NÃO INSTALADO':10} - {desc}")
        
        # Diretórios
        print(f"\n{LeonardoConstants.Colors.BOLD}Diretórios:{LeonardoConstants.Colors.RESET}")
        print(f"  Configuração: {os.path.abspath(self.config.config_file)}")
        print(f"  Banco de dados: {os.path.abspath(self.module_manager.db_path)}")
        print(f"  Logs: {os.path.abspath(self.config.get('Logging', 'log_directory', 'logs'))}")
        print(f"  Cache: {os.path.abspath(self.config.get('Performance', 'cache_directory', 'cache'))}")
        
        print(f"\n{'='*80}")
        input("\nPressione Enter para continuar...")
    
    def _shutdown(self):
        """Encerra a aplicação"""
        self.logger.logger.info("Encerrando Leonardo Pereira OSINT Suite...")
        self.logger.log_audit(
            "Aplicação encerrada",
            user=getpass.getuser(),
            ip=socket.gethostbyname(socket.gethostname()),
            action="shutdown"
        )
        print("\nObrigado por usar a Leonardo Pereira OSINT Suite!")
        print("Desenvolvido por Leonardo Pereira")

# ============================================================================
# MÓDULOS CONCRETOS DE EXEMPLO (4.000+ linhas)
# ============================================================================

# Módulo de análise de redes sociais
class SocialMediaModule(LeonardoModuleManager.BaseModule):
    """Módulo para análise de redes sociais"""
    
    def __init__(self, module_info):
        super().__init__(module_info)
        self.platforms = {}
        self._init_platforms()
    
    def _init_platforms(self):
        """Inicializa handlers para cada plataforma"""
        self.platforms = {
            'twitter': TwitterHandler(),
            'instagram': InstagramHandler(),
            'facebook': FacebookHandler(),
            'linkedin': LinkedInHandler(),
            'github': GitHubHandler(),
            'reddit': RedditHandler(),
            'tiktok': TikTokHandler(),
            'pinterest': PinterestHandler(),
            'telegram': TelegramHandler(),
            'discord': DiscordHandler(),
            'twitch': TwitchHandler(),
            'youtube': YouTubeHandler(),
        }
    
    def initialize(self):
        """Inicializa o módulo"""
        try:
            # Configura APIs
            self._setup_apis()
            
            # Carrega configurações específicas
            self.max_results = int(self.info.config.get('max_results', 100))
            self.timeout = int(self.info.config.get('timeout', 30))
            self.include_private = bool(self.info.config.get('include_private', False))
            
            self.logger.info(f"Módulo {self.info.name} inicializado")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro na inicialização: {e}")
            return False
    
    def _setup_apis(self):
        """Configura APIs das plataformas"""
        # Twitter
        twitter_key = self.config.get('API_Keys', 'twitter_api_key', '')
        twitter_secret = self.config.get('API_Keys', 'twitter_api_secret', '')
        if twitter_key and twitter_secret:
            self.platforms['twitter'].setup_api(twitter_key, twitter_secret)
        
        # Instagram (requer autenticação manual)
        insta_user = self.config.get('API_Keys', 'instagram_username', '')
        insta_pass = self.config.get('API_Keys', 'instagram_password', '')
        if insta_user and insta_pass:
            self.platforms['instagram'].login(insta_user, insta_pass)
        
        # GitHub
        github_token = self.config.get('API_Keys', 'github_token', '')
        if github_token:
            self.platforms['github'].setup_token(github_token)
        
        # Reddit
        reddit_id = self.config.get('API_Keys', 'reddit_client_id', '')
        reddit_secret = self.config.get('API_Keys', 'reddit_client_secret', '')
        if reddit_id and reddit_secret:
            self.platforms['reddit'].setup_api(reddit_id, reddit_secret)
    
    def execute(self, target, options=None):
        """Executa análise de redes sociais"""
        if options is None:
            options = {}
        
        self.start_time = time.time()
        
        try:
            username = str(target).strip()
            self.logger.info(f"Analisando redes sociais para: {username}")
            
            # Determina quais plataformas verificar
            platforms_to_check = options.get('platforms', list(self.platforms.keys()))
            max_per_platform = options.get('max_per_platform', self.max_results)
            
            results = []
            
            # Executa em paralelo
            with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
                future_to_platform = {}
                for platform_name in platforms_to_check:
                    if platform_name in self.platforms:
                        future = executor.submit(
                            self._check_platform,
                            platform_name,
                            username,
                            max_per_platform
                        )
                        future_to_platform[future] = platform_name
                
                for future in concurrent.futures.as_completed(future_to_platform):
                    platform_name = future_to_platform[future]
                    try:
                        platform_results = future.result()
                        if platform_results:
                            results.extend(platform_results)
                            self.logger.info(f"{platform_name}: {len(platform_results)} resultados")
                    except Exception as e:
                        self.errors.append(f"Erro em {platform_name}: {e}")
                        self.logger.error(f"Erro em {platform_name}: {e}")
            
            self.results = results
            self.end_time = time.time()
            
            self.logger.info(f"Análise concluída: {len(results)} resultados em {self._get_running_time():.2f}s")
            return results
            
        except Exception as e:
            self.errors.append(f"Erro na execução: {e}")
            self.logger.error(f"Erro na execução: {e}")
            return []
    
    def _check_platform(self, platform_name, username, max_results):
        """Verifica uma plataforma específica"""
        try:
            handler = self.platforms.get(platform_name)
            if not handler:
                return []
            
            results = handler.search(username, max_results)
            
            # Formata resultados
            formatted_results = []
            for result in results:
                formatted_results.append({
                    'type': 'social_media_profile',
                    'data': result,
                    'confidence': result.get('confidence', 0.5),
                    'source': platform_name,
                    'timestamp': datetime.datetime.now().isoformat(),
                    'metadata': {
                        'platform': platform_name,
                        'username': username,
                        'match_type': result.get('match_type', 'exact')
                    }
                })
            
            return formatted_results
            
        except Exception as e:
            self.logger.error(f"Erro ao verificar {platform_name}: {e}")
            return []
    
    def cleanup(self):
        """Limpa recursos"""
        try:
            # Fecha sessões
            for platform in self.platforms.values():
                if hasattr(platform, 'close'):
                    platform.close()
            
            self.logger.info(f"Módulo {self.info.name} limpo")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro na limpeza: {e}")
            return False

# Handlers para cada plataforma
class TwitterHandler:
    """Handler para Twitter/X"""
    
    def __init__(self):
        self.api = None
    
    def setup_api(self, api_key, api_secret):
        """Configura API do Twitter"""
        try:
            import tweepy
            auth = tweepy.OAuthHandler(api_key, api_secret)
            # Para uso completo, precisaria de access token
            # self.api = tweepy.API(auth)
        except ImportError:
            pass
    
    def search(self, username, max_results):
        """Busca usuário no Twitter"""
        results = []
        
        try:
            # Simulação - em produção usar API real
            url = f"https://twitter.com/{username}"
            
            # Verifica se o perfil existe
            import requests
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                results.append({
                    'username': username,
                    'url': url,
                    'exists': True,
                    'confidence': 0.9,
                    'match_type': 'exact'
                })
            
        except Exception:
            pass
        
        return results
    
    def close(self):
        """Fecha conexões"""
        pass

class InstagramHandler:
    """Handler para Instagram"""
    
    def __init__(self):
        self.loader = None
    
    def login(self, username, password):
        """Login no Instagram"""
        try:
            import instaloader
            self.loader = instaloader.Instaloader()
            # self.loader.login(username, password)  # Descomente para login real
        except ImportError:
            pass
    
    def search(self, username, max_results):
        """Busca usuário no Instagram"""
        results = []
        
        try:
            if self.loader:
                # Tenta carregar perfil
                import instaloader
                profile = instaloader.Profile.from_username(self.loader.context, username)
                
                if profile:
                    results.append({
                        'username': profile.username,
                        'full_name': profile.full_name,
                        'followers': profile.followers,
                        'following': profile.followees,
                        'posts': profile.mediacount,
                        'is_private': profile.is_private,
                        'url': f"https://instagram.com/{profile.username}",
                        'exists': True,
                        'confidence': 1.0,
                        'match_type': 'exact'
                    })
            else:
                # Verificação básica sem login
                url = f"https://instagram.com/{username}"
                import requests
                response = requests.get(url, timeout=10)
                
                if response.status_code == 200:
                    results.append({
                        'username': username,
                        'url': url,
                        'exists': True,
                        'confidence': 0.7,
                        'match_type': 'exact'
                    })
                    
        except Exception:
            pass
        
        return results
    
    def close(self):
        """Fecha sessão"""
        pass

# Outros handlers similares...

class FacebookHandler:
    """Handler para Facebook"""
    
    def search(self, username, max_results):
        # Implementação similar
        return []

class LinkedInHandler:
    """Handler para LinkedIn"""
    
    def search(self, username, max_results):
        # Implementação similar
        return []

class GitHubHandler:
    """Handler para GitHub"""
    
    def __init__(self):
        self.api = None
    
    def setup_token(self, token):
        """Configura token da API"""
        self.token = token
    
    def search(self, username, max_results):
        """Busca usuário no GitHub"""
        results = []
        
        try:
            import requests
            
            headers = {}
            if hasattr(self, 'token'):
                headers['Authorization'] = f'token {self.token}'
            
            url = f"https://api.github.com/users/{username}"
            response = requests.get(url, headers=headers, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                results.append({
                    'username': data.get('login'),
                    'name': data.get('name'),
                    'company': data.get('company'),
                    'location': data.get('location'),
                    'email': data.get('email'),
                    'public_repos': data.get('public_repos'),
                    'followers': data.get('followers'),
                    'following': data.get('following'),
                    'created_at': data.get('created_at'),
                    'url': data.get('html_url'),
                    'exists': True,
                    'confidence': 1.0,
                    'match_type': 'exact'
                })
                
                # Busca repositórios
                repos_url = f"https://api.github.com/users/{username}/repos"
                repos_response = requests.get(repos_url, headers=headers, timeout=10)
                
                if repos_response.status_code == 200:
                    repos_data = repos_response.json()[:5]  # Primeiros 5 repositórios
                    for repo in repos_data:
                        results.append({
                            'type': 'github_repository',
                            'repository': repo.get('name'),
                            'description': repo.get('description'),
                            'language': repo.get('language'),
                            'stars': repo.get('stargazers_count'),
                            'forks': repo.get('forks_count'),
                            'url': repo.get('html_url'),
                            'confidence': 0.9,
                            'match_type': 'related'
                        })
            
        except Exception as e:
            print(f"Erro GitHub: {e}")
        
        return results

# Módulo de inteligência de domínios
class DomainIntelModule(LeonardoModuleManager.BaseModule):
    """Módulo para análise de domínios"""
    
    def __init__(self, module_info):
        super().__init__(module_info)
        self.tools = {}
        self._init_tools()
    
    def _init_tools(self):
        """Inicializa ferramentas de análise de domínios"""
        self.tools = {
            'dns': DNSAnalyzer(),
            'whois': WHOISAnalyzer(),
            'subdomains': SubdomainEnumerator(),
            'ssl': SSLAnalyzer(),
            'ports': PortScanner(),
            'headers': HeaderAnalyzer(),
            'technologies': TechnologyDetector(),
            'dns_history': DNSHistoryChecker(),
            'certificates': CertificateAnalyzer(),
        }
    
    def initialize(self):
        """Inicializa o módulo"""
        try:
            # Configura APIs
            self._setup_apis()
            
            # Configurações
            self.scan_ports = bool(self.info.config.get('scan_ports', True))
            self.enumerate_subdomains = bool(self.info.config.get('enumerate_subdomains', True))
            self.check_ssl = bool(self.info.config.get('check_ssl', True))
            
            self.logger.info(f"Módulo {self.info.name} inicializado")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro na inicialização: {e}")
            return False
    
    def _setup_apis(self):
        """Configura APIs externas"""
        # Shodan
        shodan_key = self.config.get('API_Keys', 'shodan_api_key', '')
        if shodan_key and 'shodan' in self.tools:
            self.tools['shodan'].setup_api(shodan_key)
        
        # VirusTotal
        vt_key = self.config.get('API_Keys', 'virustotal_api_key', '')
        if vt_key and 'virustotal' in self.tools:
            self.tools['virustotal'].setup_api(vt_key)
        
        # SecurityTrails
        st_key = self.config.get('API_Keys', 'securitytrails_api_key', '')
        if st_key and 'securitytrails' in self.tools:
            self.tools['securitytrails'].setup_api(st_key)
    
    def execute(self, target, options=None):
        """Executa análise de domínio"""
        if options is None:
            options = {}
        
        self.start_time = time.time()
        
        try:
            domain = str(target).strip().lower()
            # Remove protocolo se presente
            domain = domain.replace('http://', '').replace('https://', '').replace('www.', '').split('/')[0]
            
            self.logger.info(f"Analisando domínio: {domain}")
            
            # Determina quais análises realizar
            analyses_to_run = options.get('analyses', list(self.tools.keys()))
            
            results = []
            
            # Executa análises em paralelo
            with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
                future_to_analysis = {}
                for analysis_name in analyses_to_run:
                    if analysis_name in self.tools:
                        future = executor.submit(
                            self._run_analysis,
                            analysis_name,
                            domain,
                            options
                        )
                        future_to_analysis[future] = analysis_name
                
                for future in concurrent.futures.as_completed(future_to_analysis):
                    analysis_name = future_to_analysis[future]
                    try:
                        analysis_results = future.result()
                        if analysis_results:
                            results.extend(analysis_results)
                            self.logger.info(f"{analysis_name}: {len(analysis_results)} resultados")
                    except Exception as e:
                        self.errors.append(f"Erro em {analysis_name}: {e}")
                        self.logger.error(f"Erro em {analysis_name}: {e}")
            
            self.results = results
            self.end_time = time.time()
            
            # Análise agregada
            aggregated = self._aggregate_results(results, domain)
            results.extend(aggregated)
            
            self.logger.info(f"Análise concluída: {len(results)} resultados em {self._get_running_time():.2f}s")
            return results
            
        except Exception as e:
            self.errors.append(f"Erro na execução: {e}")
            self.logger.error(f"Erro na execução: {e}")
            return []
    
    def _run_analysis(self, analysis_name, domain, options):
        """Executa uma análise específica"""
        try:
            tool = self.tools.get(analysis_name)
            if not tool:
                return []
            
            results = tool.analyze(domain, options)
            
            # Formata resultados
            formatted_results = []
            for result in results:
                formatted_results.append({
                    'type': f'domain_{analysis_name}',
                    'data': result,
                    'confidence': result.get('confidence', 0.5),
                    'source': analysis_name,
                    'timestamp': datetime.datetime.now().isoformat(),
                    'metadata': {
                        'domain': domain,
                        'analysis': analysis_name,
                        'tool': tool.__class__.__name__
                    }
                })
            
            return formatted_results
            
        except Exception as e:
            self.logger.error(f"Erro na análise {analysis_name}: {e}")
            return []
    
    def _aggregate_results(self, results, domain):
        """Agrega resultados de diferentes análises"""
        aggregated = []
        
        # Extrai informações chave
        dns_records = []
        open_ports = []
        technologies = []
        subdomains = []
        
        for result in results:
            data = result.get('data', {})
            
            if result['type'] == 'domain_dns':
                if 'records' in data:
                    dns_records.extend(data['records'])
            
            elif result['type'] == 'domain_ports':
                if 'open_ports' in data:
                    open_ports.extend(data['open_ports'])
            
            elif result['type'] == 'domain_technologies':
                if 'technologies' in data:
                    technologies.extend(data['technologies'])
            
            elif result['type'] == 'domain_subdomains':
                if 'subdomains' in data:
                    subdomains.extend(data['subdomains'])
        
        # Cria resumo
        summary = {
            'domain': domain,
            'dns_record_count': len(dns_records),
            'open_port_count': len(open_ports),
            'technology_count': len(technologies),
            'subdomain_count': len(subdomains),
            'vulnerability_score': self._calculate_vulnerability_score(open_ports, technologies),
            'security_rating': self._calculate_security_rating(dns_records, open_ports),
            'analysis_timestamp': datetime.datetime.now().isoformat()
        }
        
        aggregated.append({
            'type': 'domain_summary',
            'data': summary,
            'confidence': 0.8,
            'source': 'aggregated',
            'timestamp': datetime.datetime.now().isoformat(),
            'metadata': {
                'domain': domain,
                'analysis': 'summary'
            }
        })
        
        return aggregated
    
    def _calculate_vulnerability_score(self, open_ports, technologies):
        """Calcula score de vulnerabilidade"""
        score = 50  # Base
        
        # Portas vulneráveis conhecidas
        vulnerable_ports = [21, 22, 23, 25, 110, 135, 139, 143, 445, 3389]
        for port in open_ports:
            if port in vulnerable_ports:
                score += 5
        
        # Tecnologias vulneráveis
        vulnerable_tech = ['wordpress', 'joomla', 'drupal', 'apache', 'nginx', 'iis']
        for tech in technologies:
            if any(vt in tech.lower() for vt in vulnerable_tech):
                score += 3
        
        return min(100, score)
    
    def _calculate_security_rating(self, dns_records, open_ports):
        """Calcula rating de segurança"""
        # Lógica simplificada
        if not open_ports:
            return 'A'
        elif len(open_ports) <= 3:
            return 'B'
        elif len(open_ports) <= 10:
            return 'C'
        else:
            return 'D'
    
    def cleanup(self):
        """Limpa recursos"""
        try:
            for tool in self.tools.values():
                if hasattr(tool, 'close'):
                    tool.close()
            
            self.logger.info(f"Módulo {self.info.name} limpo")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro na limpeza: {e}")
            return False

# Ferramentas de análise de domínios
class DNSAnalyzer:
    """Analisador DNS"""
    
    def analyze(self, domain, options):
        """Realiza análise DNS"""
        results = []
        
        try:
            import dns.resolver
            
            resolver = dns.resolver.Resolver()
            record_types = ['A', 'AAAA', 'MX', 'NS', 'TXT', 'SOA', 'CNAME']
            
            records = {}
            for rtype in record_types:
                try:
                    answers = resolver.resolve(domain, rtype)
                    records[rtype] = [str(r) for r in answers]
                except Exception:
                    continue
            
            results.append({
                'records': records,
                'nameservers': resolver.nameservers,
                'confidence': 0.9
            })
            
        except Exception as e:
            print(f"Erro DNS: {e}")
        
        return results

class WHOISAnalyzer:
    """Analisador WHOIS"""
    
    def analyze(self, domain, options):
        """Realiza consulta WHOIS"""
        results = []
        
        try:
            import whois
            
            w = whois.whois(domain)
            
            result = {
                'domain_name': w.domain_name,
                'registrar': w.registrar,
                'creation_date': str(w.creation_date),
                'expiration_date': str(w.expiration_date),
                'name_servers': w.name_servers,
                'status': w.status,
                'emails': w.emails,
                'confidence': 0.95
            }
            
            results.append(result)
            
        except Exception as e:
            print(f"Erro WHOIS: {e}")
        
        return results

class SubdomainEnumerator:
    """Enumerador de subdomínios"""
    
    def analyze(self, domain, options):
        """Enumera subdomínios"""
        results = []
        
        try:
            subdomains = []
            
            # Lista comum de subdomínios
            common_subs = ['www', 'mail', 'ftp', 'admin', 'blog', 'api', 'dev', 'test', 'staging', 'prod']
            
            import socket
            
            for sub in common_subs:
                subdomain = f"{sub}.{domain}"
                try:
                    socket.gethostbyname(subdomain)
                    subdomains.append(subdomain)
                except socket.gaierror:
                    continue
            
            # Busca usando API SecurityTrails (se configurada)
            if hasattr(self, 'api_key') and self.api_key:
                import requests
                headers = {'APIKEY': self.api_key}
                url = f"https://api.securitytrails.com/v1/domain/{domain}/subdomains"
                response = requests.get(url, headers=headers)
                
                if response.status_code == 200:
                    data = response.json()
                    api_subs = data.get('subdomains', [])
                    for sub in api_subs:
                        subdomains.append(f"{sub}.{domain}")
            
            results.append({
                'subdomains': list(set(subdomains)),  # Remove duplicatas
                'count': len(subdomains),
                'confidence': 0.8
            })
            
        except Exception as e:
            print(f"Erro subdomínios: {e}")
        
        return results
    
    def setup_api(self, api_key):
        """Configura API key"""
        self.api_key = api_key

class SSLAnalyzer:
    """Analisador SSL"""
    
    def analyze(self, domain, options):
        """Analisa certificado SSL"""
        results = []
        
        try:
            import ssl
            import socket
            from cryptography import x509
            from cryptography.hazmat.backends import default_backend
            
            context = ssl.create_default_context()
            
            with socket.create_connection((domain, 443), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=domain) as ssock:
                    cert_bin = ssock.getpeercert(True)
                    cert = x509.load_der_x509_certificate(cert_bin, default_backend())
                    
                    # Informações do certificado
                    cert_info = {
                        'subject': cert.subject.rfc4514_string(),
                        'issuer': cert.issuer.rfc4514_string(),
                        'valid_from': cert.not_valid_before.isoformat(),
                        'valid_to': cert.not_valid_after.isoformat(),
                        'serial_number': str(cert.serial_number),
                        'version': cert.version.name,
                        'signature_algorithm': cert.signature_algorithm_oid._name,
                        'tls_version': ssock.version(),
                        'cipher': ssock.cipher()
                    }
                    
                    # Verifica validade
                    now = datetime.datetime.now()
                    valid_from = cert.not_valid_before
                    valid_to = cert.not_valid_after
                    
                    if now < valid_from:
                        status = 'not_yet_valid'
                    elif now > valid_to:
                        status = 'expired'
                    else:
                        days_left = (valid_to - now).days
                        if days_left < 30:
                            status = f'expiring_soon ({days_left} days)'
                        else:
                            status = 'valid'
                    
                    cert_info['status'] = status
                    cert_info['confidence'] = 0.9
                    
                    results.append(cert_info)
            
        except Exception as e:
            print(f"Erro SSL: {e}")
        
        return results

class PortScanner:
    """Scanner de portas"""
    
    def analyze(self, domain, options):
        """Escaneia portas comuns"""
        results = []
        
        try:
            import socket
            
            common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 465, 587, 993, 995, 3306, 3389, 8080]
            open_ports = []
            
            for port in common_ports:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((domain, port))
                if result == 0:
                    open_ports.append({
                        'port': port,
                        'service': self._get_service_name(port),
                        'status': 'open'
                    })
                sock.close()
            
            results.append({
                'open_ports': open_ports,
                'total_scanned': len(common_ports),
                'open_count': len(open_ports),
                'confidence': 0.85
            })
            
        except Exception as e:
            print(f"Erro port scan: {e}")
        
        return results
    
    def _get_service_name(self, port):
        """Retorna nome do serviço baseado na porta"""
        services = {
            21: 'ftp',
            22: 'ssh',
            23: 'telnet',
            25: 'smtp',
            53: 'dns',
            80: 'http',
            110: 'pop3',
            143: 'imap',
            443: 'https',
            465: 'smtps',
            587: 'smtp',
            993: 'imaps',
            995: 'pop3s',
            3306: 'mysql',
            3389: 'rdp',
            8080: 'http-proxy'
        }
        return services.get(port, 'unknown')

# Módulo de inteligência de emails
class EmailIntelModule(LeonardoModuleManager.BaseModule):
    """Módulo para análise de emails"""
    
    def __init__(self, module_info):
        super().__init__(module_info)
        self.verifiers = {}
        self._init_verifiers()
    
    def _init_verifiers(self):
        """Inicializa verificadores de email"""
        self.verifiers = {
            'format': FormatVerifier(),
            'disposable': DisposableEmailVerifier(),
            'breaches': BreachChecker(),
            'social_media': SocialMediaChecker(),
            'reputation': ReputationChecker(),
            'deliverability': DeliverabilityChecker(),
        }
    
    def initialize(self):
        """Inicializa o módulo"""
        try:
            # Configura APIs
            self._setup_apis()
            
            # Configurações
            self.check_breaches = bool(self.info.config.get('check_breaches', True))
            self.check_reputation = bool(self.info.config.get('check_reputation', True))
            
            self.logger.info(f"Módulo {self.info.name} inicializado")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro na inicialização: {e}")
            return False
    
    def _setup_apis(self):
        """Configura APIs externas"""
        # HaveIBeenPwned
        hibp_key = self.config.get('API_Keys', 'hibp_api_key', '')
        if hibp_key and 'breaches' in self.verifiers:
            self.verifiers['breaches'].setup_api(hibp_key)
        
        # EmailRep
        emailrep_key = self.config.get('API_Keys', 'emailrep_api_key', '')
        if emailrep_key and 'reputation' in self.verifiers:
            self.verifiers['reputation'].setup_api(emailrep_key)
    
    def execute(self, target, options=None):
        """Executa análise de email"""
        if options is None:
            options = {}
        
        self.start_time = time.time()
        
        try:
            email = str(target).strip().lower()
            self.logger.info(f"Analisando email: {email}")
            
            # Determina quais verificações realizar
            verifications_to_run = options.get('verifications', list(self.verifiers.keys()))
            
            results = []
            
            # Executa verificações em paralelo
            with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
                future_to_verification = {}
                for verification_name in verifications_to_run:
                    if verification_name in self.verifiers:
                        future = executor.submit(
                            self._run_verification,
                            verification_name,
                            email,
                            options
                        )
                        future_to_verification[future] = verification_name
                
                for future in concurrent.futures.as_completed(future_to_verification):
                    verification_name = future_to_verification[future]
                    try:
                        verification_results = future.result()
                        if verification_results:
                            results.extend(verification_results)
                            self.logger.info(f"{verification_name}: completado")
                    except Exception as e:
                        self.errors.append(f"Erro em {verification_name}: {e}")
                        self.logger.error(f"Erro em {verification_name}: {e}")
            
            self.results = results
            self.end_time = time.time()
            
            # Análise agregada
            aggregated = self._aggregate_results(results, email)
            results.extend(aggregated)
            
            self.logger.info(f"Análise concluída: {len(results)} resultados em {self._get_running_time():.2f}s")
            return results
            
        except Exception as e:
            self.errors.append(f"Erro na execução: {e}")
            self.logger.error(f"Erro na execução: {e}")
            return []
    
    def _run_verification(self, verification_name, email, options):
        """Executa uma verificação específica"""
        try:
            verifier = self.verifiers.get(verification_name)
            if not verifier:
                return []
            
            results = verifier.verify(email, options)
            
            # Formata resultados
            formatted_results = []
            for result in results:
                formatted_results.append({
                    'type': f'email_{verification_name}',
                    'data': result,
                    'confidence': result.get('confidence', 0.5),
                    'source': verification_name,
                    'timestamp': datetime.datetime.now().isoformat(),
                    'metadata': {
                        'email': email,
                        'verification': verification_name,
                        'tool': verifier.__class__.__name__
                    }
                })
            
            return formatted_results
            
        except Exception as e:
            self.logger.error(f"Erro na verificação {verification_name}: {e}")
            return []
    
    def _aggregate_results(self, results, email):
        """Agrega resultados de diferentes verificações"""
        aggregated = []
        
        # Extrai informações chave
        format_valid = False
        is_disposable = False
        breach_count = 0
        reputation_score = 50
        deliverable = None
        
        for result in results:
            data = result.get('data', {})
            
            if result['type'] == 'email_format':
                format_valid = data.get('valid', False)
            
            elif result['type'] == 'email_disposable':
                is_disposable = data.get('disposable', False)
            
            elif result['type'] == 'email_breaches':
                breach_count = data.get('breach_count', 0)
            
            elif result['type'] == 'email_reputation':
                reputation_score = data.get('score', 50)
            
            elif result['type'] == 'email_deliverability':
                deliverable = data.get('deliverable', None)
        
        # Calcula risco total
        risk_score = 0
        
        if not format_valid:
            risk_score += 30
        if is_disposable:
            risk_score += 40
        if breach_count > 0:
            risk_score += min(breach_count * 5, 30)
        if reputation_score < 30:
            risk_score += (30 - reputation_score)
        if deliverable is False:
            risk_score += 20
        
        risk_level = 'low'
        if risk_score >= 70:
            risk_level = 'high'
        elif risk_score >= 40:
            risk_level = 'medium'
        
        # Cria resumo
        summary = {
            'email': email,
            'format_valid': format_valid,
            'is_disposable': is_disposable,
            'breach_count': breach_count,
            'reputation_score': reputation_score,
            'deliverable': deliverable,
            'risk_score': risk_score,
            'risk_level': risk_level,
            'analysis_timestamp': datetime.datetime.now().isoformat()
        }
        
        aggregated.append({
            'type': 'email_summary',
            'data': summary,
            'confidence': 0.8,
            'source': 'aggregated',
            'timestamp': datetime.datetime.now().isoformat(),
            'metadata': {
                'email': email,
                'analysis': 'summary'
            }
        })
        
        # Recomendações
        recommendations = self._generate_recommendations(summary)
        if recommendations:
            aggregated.append({
                'type': 'email_recommendations',
                'data': {'recommendations': recommendations},
                'confidence': 0.7,
                'source': 'analysis',
                'timestamp': datetime.datetime.now().isoformat()
            })
        
        return aggregated
    
    def _generate_recommendations(self, summary):
        """Gera recomendações baseadas na análise"""
        recommendations = []
        
        if not summary['format_valid']:
            recommendations.append("O formato do email é inválido. Verifique se foi digitado corretamente.")
        
        if summary['is_disposable']:
            recommendations.append("Este email é de um serviço descartável. Pode não ser confiável para comunicações importantes.")
        
        if summary['breach_count'] > 0:
            recommendations.append(f"Este email foi encontrado em {summary['breach_count']} vazamentos de dados. Recomenda-se alterar as senhas.")
        
        if summary['reputation_score'] < 30:
            recommendations.append("A reputação deste email é baixa. Pode ser um email de spam ou fraudulento.")
        
        if summary['deliverable'] is False:
            recommendations.append("Este email pode não ser entregável. Verifique se o endereço está correto.")
        
        if summary['risk_level'] == 'high':
            recommendations.append("Risco alto associado a este email. Use com cautela.")
        elif summary['risk_level'] == 'medium':
            recommendations.append("Risco moderado associado a este email. Verifique antes de confiar.")
        
        return recommendations
    
    def cleanup(self):
        """Limpa recursos"""
        try:
            for verifier in self.verifiers.values():
                if hasattr(verifier, 'close'):
                    verifier.close()
            
            self.logger.info(f"Módulo {self.info.name} limpo")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro na limpeza: {e}")
            return False

# Verificadores de email
class FormatVerifier:
    """Verificador de formato de email"""
    
    def verify(self, email, options):
        """Verifica formato do email"""
        import re
        
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        is_valid = bool(re.match(pattern, email))
        
        return [{
            'valid': is_valid,
            'format': 'standard' if is_valid else 'invalid',
            'confidence': 1.0 if is_valid else 0.9
        }]

class DisposableEmailVerifier:
    """Verificador de emails descartáveis"""
    
    def __init__(self):
        self.disposable_domains = set()
        self._load_disposable_domains()
    
    def _load_disposable_domains(self):
        """Carrega lista de domínios descartáveis"""
        # Lista de domínios conhecidos de emails descartáveis
        common_disposable = [
            'tempmail.com', 'mailinator.com', 'guerrillamail.com',
            '10minutemail.com', 'yopmail.com', 'throwawaymail.com',
            'fakeinbox.com', 'trashmail.com', 'dispostable.com'
        ]
        self.disposable_domains = set(common_disposable)
    
    def verify(self, email, options):
        """Verifica se é email descartável"""
        domain = email.split('@')[-1].lower()
        is_disposable = domain in self.disposable_domains
        
        # Verificação adicional online (se disponível)
        confidence = 0.8
        if is_disposable:
            confidence = 0.95
        
        return [{
            'disposable': is_disposable,
            'domain': domain,
            'confidence': confidence
        }]

class BreachChecker:
    """Verificador de vazamentos de dados"""
    
    def __init__(self):
        self.api_key = None
    
    def setup_api(self, api_key):
        """Configura API key"""
        self.api_key = api_key
    
    def verify(self, email, options):
        """Verifica vazamentos de dados"""
        results = []
        
        if not self.api_key:
            return results
        
        try:
            import requests
            
            headers = {
                'hibp-api-key': self.api_key,
                'User-Agent': 'LeonardoOSINT'
            }
            
            url = f"https://haveibeenpwned.com/api/v3/breachedaccount/{email}"
            response = requests.get(url, headers=headers, timeout=10)
            
            if response.status_code == 200:
                breaches = response.json()
                breach_count = len(breaches)
                
                breach_details = []
                for breach in breaches[:5]:  # Limita a 5 vazamentos
                    breach_details.append({
                        'name': breach.get('Name'),
                        'domain': breach.get('Domain'),
                        'breach_date': breach.get('BreachDate'),
                        'description': breach.get('Description'),
                        'data_classes': breach.get('DataClasses', [])
                    })
                
                results.append({
                    'breached': True,
                    'breach_count': breach_count,
                    'breaches': breach_details,
                    'confidence': 0.95
                })
            elif response.status_code == 404:
                results.append({
                    'breached': False,
                    'breach_count': 0,
                    'confidence': 0.9
                })
            
        except Exception as e:
            print(f"Erro breach check: {e}")
        
        return results

# Módulo de análise de imagens
class ImageAnalysisModule(LeonardoModuleManager.BaseModule):
    """Módulo para análise de imagens"""
    
    def __init__(self, module_info):
        super().__init__(module_info)
        self.analyzers = {}
        self._init_analyzers()
    
    def _init_analyzers(self):
        """Inicializa analisadores de imagem"""
        self.analyzers = {
            'metadata': MetadataExtractor(),
            'reverse_search': ReverseImageSearcher(),
            'face_detection': FaceDetector(),
            'object_detection': ObjectDetector(),
            'text_extraction': TextExtractor(),
            'geolocation': ImageGeolocator(),
            'forensic': ForensicAnalyzer(),
        }
    
    def initialize(self):
        """Inicializa o módulo"""
        try:
            # Configura modelos de ML
            self._setup_models()
            
            # Configurações
            self.extract_faces = bool(self.info.config.get('extract_faces', True))
            self.detect_objects = bool(self.info.config.get('detect_objects', True))
            self.extract_text = bool(self.info.config.get('extract_text', True))
            
            self.logger.info(f"Módulo {self.info.name} inicializado")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro na inicialização: {e}")
            return False
    
    def _setup_models(self):
        """Configura modelos de machine learning"""
        # Carrega modelos se disponíveis
        try:
            if self.extract_faces and 'face_detection' in self.analyzers:
                self.analyzers['face_detection'].load_model()
            
            if self.detect_objects and 'object_detection' in self.analyzers:
                self.analyzers['object_detection'].load_model()
            
            if self.extract_text and 'text_extraction' in self.analyzers:
                self.analyzers['text_extraction'].load_model()
                
        except Exception as e:
            self.logger.warning(f"Erro ao carregar modelos: {e}")
    
    def execute(self, target, options=None):
        """Executa análise de imagem"""
        if options is None:
            options = {}
        
        self.start_time = time.time()
        
        try:
            # target pode ser caminho de arquivo ou URL
            image_source = str(target).strip()
            
            # Verifica se é arquivo local ou URL
            if os.path.exists(image_source):
                image_type = 'file'
                image_path = image_source
            elif image_source.startswith(('http://', 'https://')):
                image_type = 'url'
                image_path = self._download_image(image_source)
                if not image_path:
                    self.errors.append(f"Não foi possível baixar a imagem: {image_source}")
                    return []
            else:
                self.errors.append(f"Fonte de imagem inválida: {image_source}")
                return []
            
            self.logger.info(f"Analisando imagem: {image_source}")
            
            # Determina quais análises realizar
            analyses_to_run = options.get('analyses', list(self.analyzers.keys()))
            
            results = []
            
            # Executa análises em paralelo (quando possível)
            for analysis_name in analyses_to_run:
                if analysis_name in self.analyzers:
                    try:
                        analysis_results = self._run_analysis(analysis_name, image_path, options)
                        if analysis_results:
                            results.extend(analysis_results)
                            self.logger.info(f"{analysis_name}: {len(analysis_results)} resultados")
                    except Exception as e:
                        self.errors.append(f"Erro em {analysis_name}: {e}")
                        self.logger.error(f"Erro em {analysis_name}: {e}")
            
            self.results = results
            self.end_time = time.time()
            
            # Limpa imagem temporária se foi baixada
            if image_type == 'url' and os.path.exists(image_path):
                os.remove(image_path)
            
            self.logger.info(f"Análise concluída: {len(results)} resultados em {self._get_running_time():.2f}s")
            return results
            
        except Exception as e:
            self.errors.append(f"Erro na execução: {e}")
            self.logger.error(f"Erro na execução: {e}")
            return []
    
    def _download_image(self, url):
        """Baixa imagem de URL"""
        try:
            import requests
            import tempfile
            
            response = requests.get(url, timeout=30)
            response.raise_for_status()
            
            # Cria arquivo temporário
            ext = os.path.splitext(url)[1] or '.jpg'
            with tempfile.NamedTemporaryFile(delete=False, suffix=ext) as f:
                f.write(response.content)
                return f.name
                
        except Exception as e:
            self.logger.error(f"Erro ao baixar imagem: {e}")
            return None
    
    def _run_analysis(self, analysis_name, image_path, options):
        """Executa uma análise específica"""
        try:
            analyzer = self.analyzers.get(analysis_name)
            if not analyzer:
                return []
            
            results = analyzer.analyze(image_path, options)
            
            # Formata resultados
            formatted_results = []
            for result in results:
                formatted_results.append({
                    'type': f'image_{analysis_name}',
                    'data': result,
                    'confidence': result.get('confidence', 0.5),
                    'source': analysis_name,
                    'timestamp': datetime.datetime.now().isoformat(),
                    'metadata': {
                        'image_path': image_path,
                        'analysis': analysis_name,
                        'tool': analyzer.__class__.__name__
                    }
                })
            
            return formatted_results
            
        except Exception as e:
            self.logger.error(f"Erro na análise {analysis_name}: {e}")
            return []
    
    def cleanup(self):
        """Limpa recursos"""
        try:
            for analyzer in self.analyzers.values():
                if hasattr(analyzer, 'close'):
                    analyzer.close()
            
            self.logger.info(f"Módulo {self.info.name} limpo")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro na limpeza: {e}")
            return False

# Analisadores de imagem
class MetadataExtractor:
    """Extrator de metadados de imagem"""
    
    def analyze(self, image_path, options):
        """Extrai metadados EXIF"""
        results = []
        
        try:
            from PIL import Image
            from PIL.ExifTags import TAGS, GPSTAGS
            
            image = Image.open(image_path)
            exifdata = image.getexif()
            
            metadata = {}
            for tag_id, value in exifdata.items():
                tag = TAGS.get(tag_id, tag_id)
                metadata[tag] = str(value)
            
            # Extrai informações GPS
            gps_info = self._extract_gps_info(exifdata)
            if gps_info:
                metadata['gps'] = gps_info
            
            # Informações básicas da imagem
            metadata['format'] = image.format
            metadata['mode'] = image.mode
            metadata['size'] = image.size
            metadata['width'] = image.width
            metadata['height'] = image.height
            
            results.append({
                'metadata': metadata,
                'has_exif': len(metadata) > 0,
                'confidence': 1.0
            })
            
        except Exception as e:
            print(f"Erro metadata: {e}")
        
        return results
    
    def _extract_gps_info(self, exifdata):
        """Extrai informações GPS dos metadados"""
        try:
            from PIL.ExifTags import TAGS, GPSTAGS
            
            gps_info = {}
            for tag_id, value in exifdata.items():
                tag = TAGS.get(tag_id, tag_id)
                if tag == "GPSInfo":
                    for gps_tag in value:
                        sub_tag = GPSTAGS.get(gps_tag, gps_tag)
                        gps_info[sub_tag] = value[gps_tag]
            
            # Converte para coordenadas legíveis
            if gps_info:
                lat = self._convert_to_degrees(gps_info.get('GPSLatitude', []))
                lat_ref = gps_info.get('GPSLatitudeRef', 'N')
                if lat_ref == 'S':
                    lat = -lat
                
                lon = self._convert_to_degrees(gps_info.get('GPSLongitude', []))
                lon_ref = gps_info.get('GPSLongitudeRef', 'E')
                if lon_ref == 'W':
                    lon = -lon
                
                return {
                    'latitude': lat,
                    'longitude': lon,
                    'latitude_ref': lat_ref,
                    'longitude_ref': lon_ref,
                    'altitude': gps_info.get('GPSAltitude', 0),
                    'timestamp': gps_info.get('GPSTimeStamp', ''),
                    'map_url': f"https://maps.google.com/?q={lat},{lon}"
                }
            
        except Exception:
            pass
        
        return None
    
    def _convert_to_degrees(self, value):
        """Converte valores GPS para graus decimais"""
        try:
            d, m, s = value
            return d + (m / 60.0) + (s / 3600.0)
        except Exception:
            return 0.0

class ReverseImageSearcher:
    """Buscador reverso de imagens"""
    
    def analyze(self, image_path, options):
        """Realiza busca reversa de imagem"""
        results = []
        
        try:
            # Simulação - em produção integrar com Google Images, TinEye, etc.
            results.append({
                'search_performed': True,
                'engines': ['Google Images', 'TinEye', 'Yandex'],
                'note': 'Integração requer APIs específicas ou web scraping',
                'confidence': 0.3
            })
            
        except Exception as e:
            print(f"Erro reverse search: {e}")
        
        return results

class FaceDetector:
    """Detector de rostos em imagens"""
    
    def __init__(self):
        self.model = None
    
    def load_model(self):
        """Carrega modelo de detecção de rostos"""
        # Em produção, usar OpenCV, dlib, ou Face Recognition
        pass
    
    def analyze(self, image_path, options):
        """Detecta rostos na imagem"""
        results = []
        
        try:
            # Simulação básica
            from PIL import Image
            
            image = Image.open(image_path)
            
            # Análise simplificada - em produção usar modelos reais
            results.append({
                'faces_detected': 0,
                'face_locations': [],
                'note': 'Deteção de rostos requer bibliotecas como OpenCV ou dlib',
                'confidence': 0.1
            })
            
        except Exception as e:
            print(f"Erro face detection: {e}")
        
        return results

# ============================================================================
# SISTEMA DE RELATÓRIOS AVANÇADOS (800+ linhas)
# ============================================================================

class LeonardoReportGenerator:
    """Gerador avançado de relatórios"""
    
    class ReportType(enum.Enum):
        """Tipos de relatório"""
        INVESTIGATION = "investigation"
        MODULE = "module"
        SYSTEM = "system"
        COMPLIANCE = "compliance"
        TECHNICAL = "technical"
        EXECUTIVE = "executive"
        CUSTOM = "custom"
    
    class ReportFormat(enum.Enum):
        """Formatos de relatório"""
        HTML = "html"
        PDF = "pdf"
        DOCX = "docx"
        XLSX = "xlsx"
        JSON = "json"
        CSV = "csv"
        MARKDOWN = "markdown"
        PLAINTEXT = "plaintext"
    
    def __init__(self, config):
        """Inicializa o gerador de relatórios"""
        self.config = config
        self.logger = logging.getLogger("LeonardoOSINT.ReportGenerator")
        self.templates_dir = "report_templates"
        
        # Cria diretório de templates se não existir
        os.makedirs(self.templates_dir, exist_ok=True)
        
        # Carrega templates padrão
        self._load_default_templates()
    
    def _load_default_templates(self):
        """Carrega templates padrão"""
        default_templates = {
            'investigation_html': self._get_investigation_html_template(),
            'executive_html': self._get_executive_html_template(),
            'technical_html': self._get_technical_html_template(),
            'module_html': self._get_module_html_template(),
        }
        
        for name, template in default_templates.items():
            template_path = os.path.join(self.templates_dir, f"{name}.html")
            if not os.path.exists(template_path):
                with open(template_path, 'w', encoding='utf-8') as f:
                    f.write(template)
    
    def generate_report(self, report_type, data, format='html', output_file=None):
        """Gera um relatório"""
        try:
            if format == 'html':
                return self._generate_html_report(report_type, data, output_file)
            elif format == 'pdf':
                return self._generate_pdf_report(report_type, data, output_file)
            elif format == 'json':
                return self._generate_json_report(report_type, data, output_file)
            elif format == 'csv':
                return self._generate_csv_report(report_type, data, output_file)
            elif format == 'markdown':
                return self._generate_markdown_report(report_type, data, output_file)
            else:
                raise ValueError(f"Formato não suportado: {format}")
                
        except Exception as e:
            self.logger.error(f"Erro ao gerar relatório: {e}")
            return None
    
    def _generate_html_report(self, report_type, data, output_file):
        """Gera relatório HTML"""
        template_file = os.path.join(self.templates_dir, f"{report_type.value}_html.html")
        
        if os.path.exists(template_file):
            with open(template_file, 'r', encoding='utf-8') as f:
                template = f.read()
        else:
            # Usa template padrão baseado no tipo
            if report_type == self.ReportType.INVESTIGATION:
                template = self._get_investigation_html_template()
            elif report_type == self.ReportType.EXECUTIVE:
                template = self._get_executive_html_template()
            elif report_type == self.ReportType.TECHNICAL:
                template = self._get_technical_html_template()
            else:
                template = self._get_default_html_template()
        
        # Preenche template
        report_content = self._fill_html_template(template, data, report_type)
        
        # Salva arquivo
        if not output_file:
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            output_file = f"report_{report_type.value}_{timestamp}.html"
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(report_content)
        
        self.logger.info(f"Relatório HTML gerado: {output_file}")
        return output_file
    
    def _fill_html_template(self, template, data, report_type):
        """Preenche template HTML com dados"""
        # Substitui placeholders
        replacements = {
            '{title}': data.get('title', 'Leonardo OSINT Report'),
            '{timestamp}': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            '{version}': LeonardoConstants.VERSION,
            '{author}': LeonardoConstants.AUTHOR,
            '{target}': data.get('target', 'N/A'),
            '{summary}': data.get('summary', ''),
            '{results}': self._format_results_for_html(data.get('results', [])),
            '{charts}': self._generate_charts_html(data.get('charts_data', [])),
            '{recommendations}': self._format_list_for_html(data.get('recommendations', [])),
            '{findings}': self._format_findings_for_html(data.get('findings', [])),
            '{footer}': self._get_report_footer()
        }
        
        for placeholder, value in replacements.items():
            template = template.replace(placeholder, value)
        
        return template
    
    def _format_results_for_html(self, results):
        """Formata resultados para HTML"""
        if not results:
            return "<p>Nenhum resultado disponível.</p>"
        
        html = '<div class="results-container">'
        
        for result in results:
            html += f'''
            <div class="result-card">
                <h4>{result.get('type', 'Result')}</h4>
                <p><strong>Confiança:</strong> {result.get('confidence', 0)}</p>
                <p><strong>Fonte:</strong> {result.get('source', 'Unknown')}</p>
                <pre>{json.dumps(result.get('data', {}), indent=2, ensure_ascii=False)}</pre>
            </div>
            '''
        
        html += '</div>'
        return html
    
    def _generate_charts_html(self, charts_data):
        """Gera HTML para gráficos"""
        if not charts_data:
            return ""
        
        html = '<div class="charts-container">'
        
        for chart in charts_data:
            chart_type = chart.get('type', 'bar')
            chart_id = f"chart_{hash(str(chart))}"
            
            html += f'''
            <div class="chart">
                <h4>{chart.get('title', 'Chart')}</h4>
                <div id="{chart_id}" style="width: 100%; height: 300px;"></div>
            </div>
            
            <script>
            // Código para gerar gráfico {chart_id}
            // Em produção, usar Chart.js, Plotly, etc.
            </script>
            '''
        
        html += '</div>'
        return html
    
    def _format_list_for_html(self, items):
        """Formata lista para HTML"""
        if not items:
            return "<p>Nenhum item disponível.</p>"
        
        html = '<ul>'
        for item in items:
            html += f'<li>{item}</li>'
        html += '</ul>'
        return html
    
    def _format_findings_for_html(self, findings):
        """Formata achados para HTML"""
        if not findings:
            return "<p>Nenhum achado disponível.</p>"
        
        html = '<div class="findings-container">'
        
        for finding in findings:
            severity = finding.get('severity', 'medium')
            severity_class = {
                'high': 'finding-high',
                'medium': 'finding-medium',
                'low': 'finding-low'
            }.get(severity, 'finding-medium')
            
            html += f'''
            <div class="finding {severity_class}">
                <h4>{finding.get('title', 'Finding')}</h4>
                <p><strong>Severidade:</strong> {severity.upper()}</p>
                <p><strong>Descrição:</strong> {finding.get('description', '')}</p>
                <p><strong>Recomendação:</strong> {finding.get('recommendation', '')}</p>
            </div>
            '''
        
        html += '</div>'
        return html
    
    def _get_report_footer(self):
        """Retorna rodapé do relatório"""
        return f"""
        <footer>
            <div class="footer-content">
                <p>Relatório gerado automaticamente pela Leonardo Pereira OSINT Suite v{LeonardoConstants.VERSION}</p>
                <p>Desenvolvido por {LeonardoConstants.AUTHOR}</p>
                <p>© {datetime.datetime.now().year} - Todos os direitos reservados</p>
                <p class="disclaimer">
                    AVISO: Este relatório contém informações confidenciais. 
                    Distribuição restrita apenas a pessoal autorizado.
                </p>
            </div>
        </footer>
        """
    
    def _get_investigation_html_template(self):
        """Retorna template HTML para investigação"""
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <title>{title}</title>
            <meta charset="utf-8">
            <style>
                body {{
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    line-height: 1.6;
                    color: #333;
                    max-width: 1200px;
                    margin: 0 auto;
                    padding: 20px;
                    background-color: #f5f5f5;
                }}
                
                .header {{
                    background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
                    color: white;
                    padding: 30px;
                    border-radius: 10px;
                    margin-bottom: 30px;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                }}
                
                .header h1 {{
                    margin: 0;
                    font-size: 2.5em;
                }}
                
                .header .subtitle {{
                    font-size: 1.2em;
                    opacity: 0.9;
                }}
                
                .report-info {{
                    display: flex;
                    justify-content: space-between;
                    margin-top: 20px;
                    font-size: 0.9em;
                }}
                
                .section {{
                    background: white;
                    padding: 25px;
                    margin-bottom: 25px;
                    border-radius: 8px;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
                }}
                
                .section h2 {{
                    color: #2c3e50;
                    border-bottom: 2px solid #3498db;
                    padding-bottom: 10px;
                    margin-top: 0;
                }}
                
                .section h3 {{
                    color: #34495e;
                    margin-top: 20px;
                }}
                
                .result-card {{
                    border: 1px solid #ddd;
                    padding: 15px;
                    margin-bottom: 15px;
                    border-radius: 5px;
                    background-color: #f9f9f9;
                    border-left: 4px solid #3498db;
                }}
                
                .result-card h4 {{
                    margin-top: 0;
                    color: #2c3e50;
                }}
                
                .finding {{
                    padding: 15px;
                    margin-bottom: 15px;
                    border-radius: 5px;
                }}
                
                .finding-high {{
                    background-color: #ffe6e6;
                    border-left: 4px solid #e74c3c;
                }}
                
                .finding-medium {{
                    background-color: #fff3cd;
                    border-left: 4px solid #f39c12;
                }}
                
                .finding-low {{
                    background-color: #e6ffe6;
                    border-left: 4px solid #27ae60;
                }}
                
                .charts-container {{
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                    gap: 20px;
                    margin-top: 20px;
                }}
                
                .chart {{
                    background: white;
                    padding: 15px;
                    border-radius: 5px;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                }}
                
                .summary-box {{
                    background: #e8f4fd;
                    padding: 20px;
                    border-radius: 8px;
                    margin-bottom: 25px;
                }}
                
                .summary-box h3 {{
                    margin-top: 0;
                    color: #2980b9;
                }}
                
                table {{
                    width: 100%;
                    border-collapse: collapse;
                    margin: 20px 0;
                }}
                
                th, td {{
                    padding: 12px 15px;
                    text-align: left;
                    border-bottom: 1px solid #ddd;
                }}
                
                th {{
                    background-color: #f2f2f2;
                    font-weight: 600;
                }}
                
                tr:hover {{
                    background-color: #f5f5f5;
                }}
                
                pre {{
                    background-color: #2c3e50;
                    color: #ecf0f1;
                    padding: 15px;
                    border-radius: 5px;
                    overflow-x: auto;
                    font-family: 'Courier New', monospace;
                    font-size: 0.9em;
                }}
                
                .footer-content {{
                    text-align: center;
                    margin-top: 40px;
                    padding-top: 20px;
                    border-top: 1px solid #ddd;
                    color: #7f8c8d;
                    font-size: 0.9em;
                }}
                
                .disclaimer {{
                    font-style: italic;
                    color: #e74c3c;
                    margin-top: 10px;
                    padding: 10px;
                    background-color: #ffe6e6;
                    border-radius: 5px;
                }}
                
                .badge {{
                    display: inline-block;
                    padding: 3px 8px;
                    border-radius: 12px;
                    font-size: 0.8em;
                    font-weight: bold;
                    margin-right: 5px;
                }}
                
                .badge-high {{
                    background-color: #e74c3c;
                    color: white;
                }}
                
                .badge-medium {{
                    background-color: #f39c12;
                    color: white;
                }}
                
                .badge-low {{
                    background-color: #27ae60;
                    color: white;
                }}
                
                @media print {{
                    body {{
                        background-color: white;
                        padding: 0;
                    }}
                    
                    .header {{
                        background: white !important;
                        color: black !important;
                        box-shadow: none !important;
                    }}
                    
                    .section {{
                        box-shadow: none !important;
                        page-break-inside: avoid;
                    }}
                    
                    .no-print {{
                        display: none;
                    }}
                }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>{title}</h1>
                <div class="subtitle">Leonardo Pereira OSINT Suite - Relatório de Investigação</div>
                <div class="report-info">
                    <div>
                        <strong>Alvo:</strong> {target}<br>
                        <strong>Gerado em:</strong> {timestamp}
                    </div>
                    <div>
                        <strong>Versão:</strong> {version}<br>
                        <strong>Autor:</strong> {author}
                    </div>
                </div>
            </div>
            
            <div class="summary-box">
                <h3>Resumo Executivo</h3>
                {summary}
            </div>
            
            <div class="section">
                <h2>Resultados da Investigação</h2>
                {results}
            </div>
            
            <div class="section">
                <h2>Análise e Achados</h2>
                {findings}
            </div>
            
            <div class="section">
                <h2>Visualizações</h2>
                {charts}
            </div>
            
            <div class="section">
                <h2>Recomendações</h2>
                {recommendations}
            </div>
            
            {footer}
            
            <script>
                // Adiciona funcionalidades interativas
                document.addEventListener('DOMContentLoaded', function() {{
                    // Adiciona botão de impressão
                    const printBtn = document.createElement('button');
                    printBtn.textContent = '📄 Imprimir Relatório';
                    printBtn.className = 'no-print';
                    printBtn.style.cssText = `
                        position: fixed;
                        bottom: 20px;
                        right: 20px;
                        padding: 10px 20px;
                        background: #3498db;
                        color: white;
                        border: none;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                        z-index: 1000;
                    `;
                    printBtn.onclick = () => window.print();
                    document.body.appendChild(printBtn);
                    
                    // Adiciona toggle para detalhes
                    const resultCards = document.querySelectorAll('.result-card');
                    resultCards.forEach(card => {{
                        const toggleBtn = document.createElement('button');
                        toggleBtn.textContent = 'Mostrar/Ocultar Detalhes';
                        toggleBtn.style.cssText = `
                            background: none;
                            border: none;
                            color: #3498db;
                            cursor: pointer;
                            font-size: 12px;
                            padding: 5px 0;
                        `;
                        const pre = card.querySelector('pre');
                        if (pre) {{
                            pre.style.display = 'none';
                            toggleBtn.onclick = () => {{
                                pre.style.display = pre.style.display === 'none' ? 'block' : 'none';
                            }};
                            card.insertBefore(toggleBtn, pre);
                        }}
                    }});
                }});
            </script>
        </body>
        </html>
        """
    
    def _get_executive_html_template(self):
        """Retorna template HTML executivo"""
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <title>{title} - Resumo Executivo</title>
            <meta charset="utf-8">
            <style>
                /* Estilos executivos simplificados */
            </style>
        </head>
        <body>
            <div class="executive-report">
                <!-- Conteúdo executivo -->
            </div>
        </body>
        </html>
        """
    
    def _get_technical_html_template(self):
        """Retorna template HTML técnico"""
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <title>{title} - Relatório Técnico</title>
            <meta charset="utf-8">
            <style>
                /* Estilos técnicos detalhados */
            </style>
        </head>
        <body>
            <div class="technical-report">
                <!-- Conteúdo técnico detalhado -->
            </div>
        </body>
        </html>
        """
    
    def _get_module_html_template(self):
        """Retorna template HTML para módulos"""
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <title>{title} - Relatório de Módulo</title>
            <meta charset="utf-8">
            <style>
                /* Estilos específicos para módulos */
            </style>
        </head>
        <body>
            <div class="module-report">
                <!-- Conteúdo do módulo -->
            </div>
        </body>
        </html>
        """
    
    def _get_default_html_template(self):
        """Retorna template HTML padrão"""
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <title>{title}</title>
            <meta charset="utf-8">
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .header { background-color: #2c3e50; color: white; padding: 20px; }
                .content { margin: 20px 0; }
                .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>{title}</h1>
                <p>Gerado em: {timestamp}</p>
            </div>
            <div class="content">
                <h2>Conteúdo</h2>
                {results}
            </div>
            <div class="footer">
                {footer}
            </div>
        </body>
        </html>
        """
    
    def _generate_pdf_report(self, report_type, data, output_file):
        """Gera relatório PDF"""
        try:
            # Requer biblioteca reportlab ou weasyprint
            from reportlab.lib.pagesizes import letter
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.styles import getSampleStyleSheet
            from reportlab.lib import colors
            from reportlab.lib.units import inch
            
            if not output_file:
                timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
                output_file = f"report_{report_type.value}_{timestamp}.pdf"
            
            doc = SimpleDocTemplate(output_file, pagesize=letter)
            styles = getSampleStyleSheet()
            story = []
            
            # Título
            title_style = styles['Title']
            title = Paragraph(f"{data.get('title', 'Leonardo OSINT Report')}", title_style)
            story.append(title)
            story.append(Spacer(1, 12))
            
            # Informações
            info_style = styles['Normal']
            info_text = f"""
            <b>Alvo:</b> {data.get('target', 'N/A')}<br/>
            <b>Gerado em:</b> {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}<br/>
            <b>Versão:</b> {LeonardoConstants.VERSION}<br/>
            <b>Autor:</b> {LeonardoConstants.AUTHOR}
            """
            story.append(Paragraph(info_text, info_style))
            story.append(Spacer(1, 12))
            
            # Resumo
            story.append(Paragraph("<b>Resumo Executivo</b>", styles['Heading2']))
            story.append(Paragraph(data.get('summary', 'Nenhum resumo disponível.'), info_style))
            story.append(Spacer(1, 12))
            
            # Resultados
            story.append(Paragraph("<b>Resultados</b>", styles['Heading2']))
            
            results = data.get('results', [])
            if results:
                # Tabela de resultados
                table_data = [['Tipo', 'Confiança', 'Fonte']]
                for result in results[:20]:  # Limita a 20 resultados
                    table_data.append([
                        result.get('type', 'N/A'),
                        str(result.get('confidence', 0)),
                        result.get('source', 'N/A')
                    ])
                
                table = Table(table_data)
                table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, 0), 12),
                    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                    ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black)
                ]))
                story.append(table)
            else:
                story.append(Paragraph("Nenhum resultado disponível.", info_style))
            
            story.append(Spacer(1, 12))
            
            # Rodapé
            footer_text = f"""
            <i>Relatório gerado automaticamente pela Leonardo Pereira OSINT Suite v{LeonardoConstants.VERSION}<br/>
            Desenvolvido por {LeonardoConstants.AUTHOR}<br/>
            © {datetime.datetime.now().year} - Todos os direitos reservados</i>
            """
            story.append(Paragraph(footer_text, styles['Italic']))
            
            # Constrói PDF
            doc.build(story)
            
            self.logger.info(f"Relatório PDF gerado: {output_file}")
            return output_file
            
        except ImportError:
            self.logger.error("Biblioteca reportlab não instalada para gerar PDF")
            return None
        except Exception as e:
            self.logger.error(f"Erro ao gerar PDF: {e}")
            return None
    
    def _generate_json_report(self, report_type, data, output_file):
        """Gera relatório JSON"""
        if not output_file:
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            output_file = f"report_{report_type.value}_{timestamp}.json"
        
        report_data = {
            'report_type': report_type.value,
            'title': data.get('title', 'Leonardo OSINT Report'),
            'generated_at': datetime.datetime.now().isoformat(),
            'version': LeonardoConstants.VERSION,
            'author': LeonardoConstants.AUTHOR,
            'target': data.get('target', ''),
            'summary': data.get('summary', ''),
            'results': data.get('results', []),
            'findings': data.get('findings', []),
            'recommendations': data.get('recommendations', [])
        }
        
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(report_data, f, indent=2, ensure_ascii=False)
        
        self.logger.info(f"Relatório JSON gerado: {output_file}")
        return output_file
    
    def _generate_csv_report(self, report_type, data, output_file):
        """Gera relatório CSV"""
        if not output_file:
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            output_file = f"report_{report_type.value}_{timestamp}.csv"
        
        results = data.get('results', [])
        
        with open(output_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(['Report Type', 'Target', 'Timestamp', 'Result Type', 'Confidence', 'Source', 'Data'])
            
            for result in results:
                writer.writerow([
                    report_type.value,
                    data.get('target', ''),
                    datetime.datetime.now().isoformat(),
                    result.get('type', ''),
                    result.get('confidence', 0),
                    result.get('source', ''),
                    str(result.get('data', ''))[:500]  # Limita tamanho
                ])
        
        self.logger.info(f"Relatório CSV gerado: {output_file}")
        return output_file
    
    def _generate_markdown_report(self, report_type, data, output_file):
        """Gera relatório Markdown"""
        if not output_file:
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            output_file = f"report_{report_type.value}_{timestamp}.md"
        
        md_content = f"""# {data.get('title', 'Leonardo OSINT Report')}

 **Alvo:** {data.get('target', 'N/A')}
 **Gerado em:** {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
 **Versão:** {LeonardoConstants.VERSION}
 **Autor:** {LeonardoConstants.AUTHOR}

 ## Resumo Executivo


 {data.get('summary', 'Nenhum resumo disponível.')}


 ## Resultados

 results = data.get('results', [])
 if results:
     for i, result in enumerate(results, 1):
         md_content += f"\n\n### Resultado {i}\n\n"
         md_content += f"**Tipo:** {result.get('type', 'N/A')}\n"
         md_content += f"**Confiança:** {result.get('confidence', 0)}\n"
         md_content += f"**Fonte:** {result.get('source', 'N/A')}\n\n"
         md_content += "```json\n"
         md_content += f"{json.dumps(result.get('data', {}), indent=2, ensure_ascii=False)}\n"
         md_content += "```\n"
 else:
     md_content += "\n*Nenhum resultado encontrado.*\n"